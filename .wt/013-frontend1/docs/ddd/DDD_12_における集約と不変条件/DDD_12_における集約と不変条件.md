こんにちは ソフトウェア開発をしていると時々こうゾッとすることありませんか と言いますと なぜたった1個の変更が全く関係ないはずの場所でバグを引き起こすんだろうって あーありますね すごくあります まるでこう複雑に絡み合った糸を1本引いたら全体がぐしゃっと崩れてしまうような感覚 わかります 今日はこの問題の根源に攻めるためのまあ一種の操作を始めたいと思います 手がかりはですねドメイン駆動設計DDDにおける集約という概念です はい 手元にあるこの資料はまさにその集約を深く解説した1000万文書でして 今回の我々のミッションはこの集約がいかにしてソフトウェアを崩壊から守る防波堤になるのか その確信をあなたと一緒に解き明かすことです いやー面白い切り口ですね その防波堤っていう表現はすごく的確だと思います ほう 多くの人がオブジェクトをまあ単なるデータの入れ物みたいに考えがちなんですけど DDDの集約は全然違うんですよ 違う ええなんていうか一つの仕事だけを任された自律的な小さなビジネスマシーンみたいなものなんです ビジネスマシーンですか 例えば銀行の窓口係を想像してみてください お金を数えたり口座に入れたりするのはその窓口係にしか許されてないですよね まあそうですねお客さんが勝手に金庫に手を入れたら大問題です 絶対に許されない 集約っていうのはまさにその窓口係であり金庫でもあるんです ビジネスの大切なルールを外部の無秩序な干渉から守るための強力な番人なんですよ なるほどデータの入れ物じゃなくてルールの番人 その視点で見るとすごく面白そうですね ええ ではまずその番人の基本的な構造から見ていきましょうか 資料に境界とルートという言葉が出てきますね はい ユーザー情報の集約が図で示されてますけど ユーザーという大きな枠が境界で その中にユーザーIDとかユーザーネールといった要素が入っている そうですね そして全ての指示はこのユーザーオブジェクト つまり集約ルートを通して行わなければならないと その通りです そしてその確信はですね 境界の外からは中の要素 例えばユーザーネームを直接書き換えることが

がもう固く禁じられているという 点にあるんです 資料のコード例がまさにそれですね ユーザー.ネームイコールニューネーム はダメでユーザー.チェンジネーム カッコニューネームというメソッド を使えと ええ 正直なところこれだけ見ると単なる コーディングスタイルの問題では って感じる人もいると思うんですよ はいはいそう見えますよね なぜこの直接の代入を禁止する ことがそこまで決定的に重要になるん でしょうか それは単なるスタイルじゃなくて ビジネスルールをコードそのもの に埋め込むための生命線だから なんです 生命線 そのチェンジネームメソッドの中 には例えばユーザー名は空では あってはならないとか特定の禁止 ワードを含んではいけないとか ビジネス上の絶対に守られるべき ルールを記述できるわけです ああなるほど 専門用語で言う普遍条件ってやつ ですねもし直接代入を許してしま ったらこれらのチェックをすり 抜けてシステムにとって不正な 状態のデータが簡単に作られて しまう うわそれが怖いですね 集約はそういうルール違反が構造 的に起こり得ないようにするための 仕組みなんです ルール違反を気をつけるんじゃなくて 構造的に不可能にすると まさに市場にあるサークルの例 がわかりやすいでしょうサークル のメンバーはオーナーを含めて30 名までっていう普遍条件があった とします はい 誰でもサークル.メンバーズ.アッド みたいにメンバーリストを直接 いじれてしまったらどうなります か ああもうあっという間に31人32人 と入れてしまってルールが全く 意味をなさなくなりますね そうなんですよそこでメンバー 追加の操作をサークル.ジョイン メンバーっていうメソッドに一本化 するんです ふむふむ そしてそのジョインメソッドの 中で必ず今のメンバー数が30名 未満かをチェックするロジック を入れておく なるほど こうすれば開発者がうっかりして いても極端な話悪意があったとしても 30名の上限を超えることは物理 的に不可能になるんです これが集約が番人として機能する っていうことなんですね ええ なるほどなあでこの番人を通せ っていう考え方実はプログラミング の別の有名な原則にもつながっている と資料は指摘していますね ええこの集約によるルール保護 の考え方は実はデメテルの法則 という

と裏で表一体なんですデメテルの法則知らない人に話しかけるなでしたっけ そうですそのオブジェクト思考の古い原則ですねさっきのサークル.メンバーズ.アッド メンバーというコードはサークルという知り合いを通り抜けてその奥にいる メンバーズっていう知らない相手に直接話しかけているからこの法則に違反していると a その通りです でもこれも直感的で書きやすいと感じる開発者多いと思うんです その便利さをちょっと犠牲にしてまでこの法則を守る価値って毒にあるんでしょう そのちょっとの便利さが将来とんでもないコストを要求してくるんですよ 資料が指摘している最大の問題はロジックの天才です 上限をチェックするい風サークル.メンバーズ.カウント30みたいのコードが メンバーを追加する機能の数だけシステムのあちこちにコピー&ペーストされてしまう うわぁ 想像しただけでメンテナンスしたくないですねそれ でしょそしてある日ビジネス要件が変わって上限を50名にしましょうってなった時 悲劇が起こるわけです 天才するすべてのチェック箇所を探し出して一つ残らず修正しなきゃいけない 一つでも見逃せばそれがバグになるそれは地獄ですね 資料の身盛らの首を真綿で締めるような行為っていう表現はまさにこの状況を指して いるんです 以前関わったプロジェクトでまさにこのロジックの天才が原因でリリース直前に使用変更 が入って修正漏れを探すのに数日を冷やした経験がありますよ なるほど つまりその場しのぎの便利さのためにルールそのものがコードのあちこちに散らばって見えない 不細になってしまうわけですねその通りです だからこそサークル.ジョインメンバーみたいにロジックを一つの場所に集約しておく そうすればルールの変更はそのメソッド一箇所を修正するだけで完了しますから これがソフトウェアを長期的に健全に保つためのものすごく重要な考え方なんです この集約という番人が非常に強力なのはよくわかりました でもだからこそ一番難しい問題が出てきますよね と言いますとどこからどこまでを一つの集約として囲い込むべきなのか この境界線の引き方が一番の悩みどころだと思うんです そこがまさに設計者の腕の見せどころですね 資料が示している最も重要な指針はトランザクション

トランザクションの単位、つまり一度の操作で一貫性を保つべき範囲で考えることです トランザクションの単位? 資料の例ではサークルとユーザーは別々の集約になっていますよね はい、なっていますね ここで境界設定を間違えてサークル情報を変更するトランザクションで ついでにメンバーであるユーザーの名前まで変更できるような巨大な集約を作ってしまったらどうなると思いますか? なんだかいろんなものが密結合してすごく厄介なことになりそうな予感がします その厄介さが具体的にどこに現れるか、非常に興味深いのが それがリポジトリデータを永続化するクラスに牙を吐くんです リポジトリに? サークルを保存するはずのサークルリポジトリが なぜかユーザー情報を更新するロジックまで抱え込むことになる 本来の責務を大きく逸脱していると? ええ、自分の仕事じゃないことまでやらせられていると はいはい 似たような更新ロジックがユーザーリポジトリとサークルリポジトリに重複して存在したりして システムの複雑さが爆発的に増大します それは避けたいですね これを避けるための驚くほどシンプルで効果的なルールが資料で提示されているんです それがインスタンスではなくIDで関連を持つことです というと具体的にはどういうことですか? つまりサークルオブジェクトがメンバーのユーザーオブジェクトそのもののリストを直接持つんじゃなくて ユーザーIDという識別紙のリストを持つように設計するんです ああなるほど IDしか持っていないでいればそもそも間違ってユーザーのメソッド 例えばチェンジネームとかを呼び出してしまう物理的な可能性がなくなりますね そうなんです これはうっかりミスを防ぐ強力な制約になりますね まさにそれにこれはパフォーマンスにも劇的に効いてきます パフォーマンスにもですか? 考えてみてください サークルの名前を変えたいだけなのにメンバーである100人全員のユーザー情報をデータベースからごっそり読み込んで メモリに載せるのはリソースの壮大な無駄遣いじゃないですか? 確かにそれは無駄ですね IDで関連を持てば本当にそのユーザー情報が必要になった時まで読み込みを遅らせることができるんです 理論は本当に美しいですね ただ現実の開発ではそう簡単にはいかない問題も出てきそうですね ええおっしゃる通りです 例えば集約の内部データを完全に隠蔽しすぎると 今度はリポジトリがデータを読み取れず保存できなくなるっていうジレンマに陥ると資料にありました

ここは理論と現実のせめぎ合いですね 資料ではいくつかの現実的な解決策が紹介されています 一つはチーム内での真摯協定ですね このメソッドはリポジトリからしか使わないようにしようねとルールで運用する方法 コストは低いですけど吐けられる可能性は常にあります 人に依存しますからね もう一つは少し手間をかけて通知オブジェクトみたいなパターンを使う方法です 集約が自身の状態を専用のオブジェクトにコピーして渡して リポジトリはそれを使って保存する なるほど内部の隠蔽は保たれますけど少し実装が複雑になります 完璧な銀の弾丸はなくてプロジェクトの状況に応じたトレードオフの判断が求められる わけです そうしたトレードオフの話で言うと集約はなるべく小さく保つべき というアドバイスも非常に実用的だと感じました はい重要ですね単にコードがきれいになるって話だけじゃなくて データベースのロック範囲が広がりすぎてシステムの性能に影響を与えるのを防ぐという現実的な理由があるんですね 非常に重要なプラクティスです 大きな集約を更新しようとすると広範囲のデータがロックされて他のユーザーの処理を待たせてしまう可能性がありますからね はいそしてどうしても複数の集約をまたぐ処理が必要な場合は 結果整合性という考え方を受け入れることも重要になってきます ある一瞬の矛盾は容認しつつ最終的に辻褄が合えば良いというアプローチですね ええすべての処理が常に100%リアルタイムで整合性を保つ必要はないという視点の転換は面白いですよね 確かに そして最後にこれはもうプログラマーなら誰もが肝に銘じるべきという指摘がありました 言葉との組合を消すことです あの29という数字の例ですね メンバーは最大30名というルールなのに コードにメンバーズ.カウントイコール29と書かれていたら混乱するという そうですそのコードを見た開発者は一瞬 えっなんで29オーナーは別カウント0から始まるからって余計な思考を費いられるんです あーやりますねその飛行 この一瞬の迷いや誤解の積み重ねがバグの温床になる そこでオーナーも含めたメンバーを返すカウントメンバーズというメソッドを用意して イフーカッカカウントメンバーズイコール30と書く なるほど こうすればコードがビジネスルールそのもの

を語り始めます コードを読むだけでシステムの振る舞いが直感的に理解できる これは長期的な保守性を考える上で本当に価値のあることなんです さて我々の操作も過強ですね これらすべてをつなぎ合わせると何が見えてくるでしょうか 冒頭の謎なぜたった1本の変更がシステム全体を壊すことがあるのか はいその答えはビジネス上の大切なルールが コードのあちこちにのもなしにされて守るべき境界がなかったからと言えそうですね まさに そして集約とはそのルールを守るための境界線をコードの世界に引き その責務を全うする番人を配置する行為なんですふむ その番人がいるからこそシステムの一部を変更しても予期せぬ副作用が他に広がっていく のを防げる 時間経過による変更という避けられない圧力に対してソフトウェアをしなやかで強いものに してくれるんです なるほどもっといえば集約とは未来の自分やチームメイトを避けられたはずの複雑さから守る ための契約書なんです未来の自分への契約書ですか ええ一つ一つの集約がその契約を忠実に守り続けることで巨大なシステム全体が 健全性を保ち続けることができるのです いや非常に示唆に富む言葉ですね集約の設計というのは単なる技術的な作業ではなくて ビジネスの革新とシステムの制約を深く理解してバランスを取りながら 未来への責任を果たす創造的な行為だということがよくわかりました a 最後にあなたに考えてみていただきたいことがあります 今日複数の集約を扱うための一つの考え方として結果整合性というアイデアが紹介され ました はいあなたが日常的に使うネット通販サイトや sns を思い浮かべてみてください 商品を注文したときあるいは投稿にいいねを押したとき 在庫数の更新やポイントの付与友人への通知 タイムラインへの反映といった関連するすべての処理は本当にコンマ1秒の狂いもなく 完全に同時に行われているでしょうか それともほんの少しの時間のズレを許容しながら最終的に正しい状態に落ち着いている のでしょうか あなたが気づかないうちにこの結果整合性という仕組みが静かに機能している場面はどこに あると思いますか