さて今回深掘りしていくテーマなんですけどもドメイン駆動設計 まあ通称DDDですね はい この中核をなするエンティティーという概念です お送りいただいた資料これ非常にわかりやすかったんですけど正直僕も昔データベース を学んだ時にエンティティーって言葉に触れたくらいでして あーよくありますよね DDDの世界だとどうも意味合いが少し違うというか もっと深い意味があるみたいなんですよね なので今回の探究ではその違いをはっきりさせて優れたソフトウェア設計でこのエンティティー という考え方がなぜこれほど重要なのかをあなたと一緒に解き明かしていければなと そのデータベースのエンティティーとは違うっていう点 まさに今日の話の出発点になりますね ソフトウェアっていうのは現実世界の複雑なことをモデル化する試みじゃないですか はいそうですね 現実には時間が経つにつれて見た目とかは変わるけど 本質的には同じものであり続けるっていう概念がたくさんあるんですよね あーなるほど 一番わかりやすいのがあなた自身です 例えば5歳の頃と今とでは身長も体重も考え方も全然違う 全然違いますね でも紛れもなく同じあなたですよね この時間を通じた同一性っていうちょっと厄介で でも本質的な概念をどうやってロジックとデータの世界であるプログラムで表現するのか それが今回の革新なんです 時間を通じた同一性なるほど 言われてみればプログラムで扱うものって大体時間と共に変化しますもんね では早速ですが資料にある最も重要なポイント エンティティは属性ではなく同一性アイデンティティによって識別されるという部分からいきましょうか 今の話でイメージは湧きましたけどこれをコードの世界に落とし込むとどういうことなん でしょう はいこれを理解するには体になる概念の値オブジェクト バリューオブジェクトですねこれと比較するのが一番わかりやすいです 値オブジェクト例えば資料にもある氏名という値を考えてみましょう 山田太郎さんこの名前は山田っていう系と太郎っていう名の組み合わせ つまり属性そのものなんです もし結婚と

とかで k が鈴木に変わったらそれはもう山田太郎とは全くの別人というか別の値になると そうですそうです属性が変わればそれはもう別物 これが値オブジェクトの考え方です属性がそのものの本質を定義しているってことですね じゃあエンティティの代表例として挙げられているユーザーの場合はどうですかはい 例えばユーザーがユーザー名を太郎からスーパー太郎に変えたとします ユーザー名は変わったけどアカウント自体はもちろん同じものですよね a これが属性が変わっても同一性が維持されるということですね まさにその通りですでここが面白い点でじゃあプログラムはどうやって スーパー太郎さんが昔の太郎さんと同じ人物だって認識しているのか 確かにそれはユーザー名とか年齢みたいな目に見える属性じゃなくて 我々が裏でこっそり割り当てている 絶対に変わらないユーザー id みたいなものを見ているからなんですああ この id こそがエンティティの同一性の正体です なるほど僕たちが見ているプレフィール情報とは別にシステムだけが知っている背番号 みたいなもので管理しているから属性がいくら変わっても同じ人だって判断できるわけ か a ここで一つ気になったんですけど資料に ddd のエンティティは er 図のエンティティとは区別して考える武器ってありますよね データベースのテーブルも id で1一行一行管理しますからすごく似てるように感じるんです けどこれは何が違うんですか あー非常に多い質問ですね形は似てるんですけど目的が根本的に違います 目的ですか データベースの er 図のエンティティっていうのは主にどうやってデータを効率よく 矛盾なく保存するかっていうデータの格納方法に焦点が当たってるんです はい一方で ddd のエンティティはこのシステムが扱うべき世界のルールとか振る舞いをどう コードで表現するかっていう ビジネスロジックとそのものに焦点を当てています ビジネスロジック a データを入れるただの箱じゃなくて意味のあるルールを持った存在 ということなんですルールを持った存在 えっとどういうことでしょう例えばユーザーの属性が変わることを可変であると資料では説明して ますけどこれって単にデータを書き換えられるっていうのとは違うんですか 全く違います

ますねむしろここがエンティティー を導入する大きなメリットの一つ でしてもしエンティティーが単なる データの入れ物例えばパブリック ストリングネームゲットセット みたいなコードだったら誰でも いつでもどんな値にでも名前を 書き換えられちゃうじゃないですか ああそれは危ないですね ですよね資料にあるユーザークラス のチェンジネームメソッドの例 を見てみてくださいこのメソッド の中にはユーザー名は3文字以上 でなければならないっていうこの システム固有のビジネスルール がちゃんと組み込まれてるんです ああなるほど単にデータをセット するんじゃなくて名前を変更する っていうビジネス上の意味のある 行為としてメソッドが定義されて てその中にルールが埋め込まれて るんですね その通りです だからルールに反するような不正な 変更は絶対に起こらないこれが ルールに守られた変更ってこと ですか まさにエンティティは自身の状態 を自身のルールに従って責任を 持って管理するままるで自立した 存在のように振る舞うわけです 面白いですね これがルールを持った存在っていう 意味なんです なるほどじゃあそうなると次の 疑問が湧いてきます属性は変わる とでももし同じ名前で同じ年齢 のユーザーが2人システムに登録 されたらシステムはどうやって こっちがaさんであっちがbさん だって見分けるんでしょう それが先ほど少し触れた識別し アイデンティファイヤーの役割 ですね あid そしてエンティティの2つ目の性質 同じ属性であっても区別される につながる話です資料の同性同名 の人間は別人であるっていう例え が分かりやすいですけどプログラム の世界でも同じです 例えば山田太郎30歳っていう属性 が全く同じユーザーが2人いた としてもシステムが内部で割り 当てるユーザーidは例えばユーザー 123とユーザー456みたいに必ずユニーク になります人間が名前で区別する ようにシステムはこのidで彼ら をメーカーに別人として区別する わけです ということは3つ目の性質同一性 により区別されるっていうのは つまりプログラムが2人のユーザー を比べるとき名前とか年齢とか の属性は一切見ずにこのidだけを 比較して同じかどうかを判断する ってことですか その通りです

資料にあるイーコールスメソッドの実装例がまさにそれを示してますよね あ、ありましたね 2つのユーザーオブジェクトが等しいかどうかをチェックするロジックが this.id イコール other.id みたいに ID の比較だけになってる ほんとだ これによってユーザーが名前を変更する前のオブジェクトと 変更した後のオブジェクトを比較しても ID が同じなので プログラムはこれは同一人物だと正しく認識できる 属性の揺らぎに惑わされずに 本質的な同一性を見抜けるんです いやーよくわかりました 概念はつかめてきたんですけど いざ自分で設計するってなると迷いそうで 例えば住所ってどうなんでしょう お、いいとこつきますね 引越しで変わるからライフサイクルがあるようにも見えますし エンティティっぽい気もするんですが ある概念が値オブジェクトなのかエンティティなのか どう判断したらいいんでしょうか いやー素晴らしい例ですね 住所はまさに多くの設計者が悩むポイントです やっぱりそうですか でその答えを導くための強力な判断基準が 資料にあるライフサイクルと連続性ともう一つコンテクストなんです ライフサイクルとコンテクスト まずその概念に生まれてから消えるまで その状態を追跡し続ける必要があるかって自問します ユーザーは登録つまり誕生があって 情報更新という人生があって 大会つまり死という明確なライフサイクルがある はい 我々はその移り変わりを追跡したいだからエンティティです じゃあ住所はどうか ほとんどのECサイトだと ユーザーの今の住所が分かればよくて 去年はどこに住んでたかみたいな履歴は追跡する必要ないですよね まあそうですね この場合住所は単なる文字列 つまり値オブジェクトとして扱うのが適切です なるほど追跡する必要があるかどうかが鍵なんですね でも例えば住民票を管理するような行政システムだったら 過去の住所履歴ってむちゃくちゃ重要ですよね その場合は その通りそのコンテキスト つまり行政システムという文脈においては 住所は居住履歴というライフサイクルを持つ 重要なエンティティとして扱われるべきでしょう このように同じ住所っていう概念でも どのシステムのどの視点から見るかで 値オブジェクトにもエンティティにもなり得る これがシリアス

にあるタイヤの例が示唆しているところなんです タイヤの例面白かったです車のドライバーにとってはタイヤは性能とかサイズが 同じならどれでもいい交換可能な部品 つまり値オブジェクトでもタイヤ工場にとっては個々のタイヤはロット番号で厳密に 管理されて製造から廃棄まで追跡されるべきエンティティになる そうなんです同じものでも立場が変わればモデルの形が変わるっていうのは本当に奥が 深いですね a ですからこれは絶対にエンティティだって断定する前に一歩立ち止まって このシステムにとってこの概念のライフサイクルを追跡することは本当に重要か と問いかける姿勢が優れた設計につながるんです なるほどなぁ さてここまでエンティティとは何かどう見分けるかを見てきましたけど 最後になぜそもそもこんな面倒な区別をすることが重要なのか その価値について深く考えていきたいです はい資料は饒舌なコードと無口なコードっていう対比で説明してますけどこの表現が すごく刺さりました 無口なコード多くの現場で見ていきましたね さっきも出たパブリックストリングネームゲットセットみたいなコードです はいはいこれは単にネームっていう文字列型のデータが入る箱ですよとしか言ってない これを見ただけではさっきのユーザー名は3文字以上っていう すごく重要なビジネスルールはどこにも書かれてない まさに沈黙しているんですそうなるとそのルールを知らない別のプログラマーが 2文字のユーザー名を登録する処理をうっかり書いてしまうかもしれない その通りですそしてそのバグを防ぐために画面の入力チェック サーバー側の apa のチェックバッジ処理のチェックとプログラムのあちこちに同じ 3文字以上かっていうチェック処理が散らばっていくんです これが無口なコードがもたらす悲劇です 一方饒舌なコードは資料のユーザーネームクラスのように ルール自体がコードに内包されています ユーザーネームオブジェクトを作ろうとした時点で3文字未満なら例外を投げるって コード自身が主張してくれるんです まさにコード自体が使用書として機能している状態ですね これなら使用書を読みに行かなくてもユーザーネームクラスの使い方を見ればルールが一目瞭然 そしてその価値が最も発揮されるのが使用変更の時なんです 使用変更 以前ある

プロジェクトでまさにこの無口な コードの問題に直面したんですよ ユーザー名の文字数制限を3文字 以上から6文字以上に変更するっていう まあそれだけの簡単な修正のはず でした はい ところがそのチェックロジック が20箇所以上に散らばっていて 案の定3箇所も修正を漏らしてしま って本番環境でデータ不整合を 起こす大問題になりました うわあそれは生々しい話ですね あの時ユーザー名っていう饒舌 なクラスが1つだけ存在していた なら修正はたったの1箇所で10分 で安全に終わっていたはずなんです 変更が容易でかつ安全になるドメイン のルールを1箇所に集約することが 将来の自分たちを助けてソフトウェイ が健全に成長していくための土台 になるんですね その通りですビジネスは常に変化 しますからその変化に柔軟かつ 堅牢に対応できる構造を最初から 作っておくことが長期的に見れば はかり知れない価値を生むんです いやあよくわかりました今回は ドメイン駆動設計のエンティティー を深掘りしてきましたけど単なる データ構造の話じゃなくて時間 を通じて変化するものの同一性 をどう捉えるかっていうなんか 哲学的な問いでもあったんですね ええ ライフサイクルとコンテクストを 見極めて識別子によってその本質 を捉えるそしてその考え方を饒舌 なコードとして表現することがいかに 変化に強いソフトウェアにつながる かその理由が痛いほど伝わりました ええそして最後にこの資料が示唆 しているさらに一歩踏み込んだ 思考をあなたと共有して終わり たいと思います 何でしょう 資料のまとめにこうありました もしもエンティティーを実装しよう としてそこに曖昧さを感じたので あればそれはドメインの捉え方 を見つめ直すきっかけですと これはつまりエンティティーという 技術的な概念はコードを書く私たち にもっと本質的な問いを投げかけ ているということなんです 本質的な問い そもそも私たちはこのシステム は扱おうとしている現実世界の 物事を一体どのように認識し区別 しそして扱っているのだろうか コードを書くという行為が対象 世界への深い洞察と理解を要求 してくるこの知的挑戦こそがドメイン 駆動設計の最も難しくそして最も 面白い点なのかもしれないですね