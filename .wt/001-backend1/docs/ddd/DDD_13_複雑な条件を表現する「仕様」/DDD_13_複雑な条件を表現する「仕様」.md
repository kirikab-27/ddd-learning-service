あなたが共有してくれた資料今回はソフトウェア設計 特にドメイン駆動設計について書かれたものですね いやーこれはまたえっと読み応えのあるテーマです ソフトウェアのまあ心臓部であるビジネスロジック いわゆるドメインといかに向き合うかという設計思想ですね ですよね多くの開発者が一度は通る道かなとはい 今回はですねこの資料の中心テーマである使用 スペシフィケーションという考え方を深掘りしていきましょう 複雑になりがちなビジネスのルールをどうやってコードの中で綺麗に整理整頓するのか そのためのなんか強力な武器のように見えますねまさに そしてただ綺麗に書くだけじゃなくてその綺麗さが まあ現実のシステムのパフォーマンスとどう折り合いをつけていくのかという非常に 実践的な話にもつながっていきます 面白そうですね例えば資料にある例がすごくわかりやすくて サークルのメンバーが30人以上なら満員っていうルール これ簡単ですよねはいシンプルですでもここにただし プレミアム会員が10人以上いれば上限は50人に触れる なんて条件が加わった途端急に話がややこしくなるなりますね この追加ルール一体どこに書くのが正解なのか 今日はその答えを探っていきましょういいですね では早速その問題の白針から見ていきましょうか はい資料のサークルの例本当にわかりやすいです 最初のうちはサークルっていうクラスに is フルみたいなメソッドを作ってメンバー数が30以上なら トゥルーを返すとこれならコードもシンプルで誰が見ても一目瞭然です そこまでは全く問題ないんです ただ先ほどのプレミアムユーザーの人数によって上限が変わるというルールが入って くるとサークルクラスだけでは完結できなくなる なぜならサークルクラスっていうのは本来メンバーがプレミアム会員かどうか なんていうその詳細な個人情報まで知るべきじゃないからです あーなるほどサークルが知ってるのはあくまでメンバーの id くらいで その人の課金状況とかまでは感知しないとそうです それを知るにはユーザー情報を管理している別の部品 資料でいうところのリポジトリに問い合わせる必要があるわけですね その通りですそしてここからだ設計の分かれ道になります 資料では多くの人がまあやってしまいがちな良くない解決策が2つ上げられて ますね 一つ目はアプリケーションサービスにロジックを書いてしまうこと アプリケーションサービスえっとユーザーからのリクエストを受けて ドメインのオブジェクトを操作する いわば全体の司令塔みたいな場所ですね a ここにまずユーザーリポジトリでプレミアム会員の数を調べてそれからサークルの メンバー数と見比べて判断するみたいな行動を書いちゃうと a 一見するとまあ必要な部品が全部そこに揃っているんで解決できそうに 見えちゃうんですよね でもこれって実はドメインのあのすごく重要なルール サークルが満員になる条件っていうそうですそれですそれがドメインの外側に つまりアプリケーションの都合を記述する層にこう漏れ出してしまっている状態なんですよ ああ あるほ同じような判定が別の場所でも必要になったらまた同じような行動を書くことになって ルールが行動のあちこちに散らばっちゃうそうなんですわかります 僕も昔似たような行動を見たことがあって最初は便利なんですけど 半年もすると条件分岐だらけの神メソッドみたいになってて誰も怖くて触れない っていうまさにあるレアですね ではもう一つの良くない解決策はどうでしょう なるほどアプリケーションサービスがダメなら じゃあ一層のことをサークルクラス自身にユーザーリポジトリを直接渡して イズフルメソッドの中でプレミアム会員を数えさせるとか いやでもそれだとドメインモデルの純粋な世界にデータベースとのやり取りみたいな インフラの都合が入り込んできちゃう それもまずそうですね素晴らしいまさにそれが一つ目のアンチパターンです 技術的には可能なんですがドメインモデルの中心であるサークルクラスがデータ保存の 仕組みっていう回レイヤーの都合に依存してしまう 純粋さが失われるとモデルの純粋さが失われてテストも複雑になります オブジェクトが本来の役割からされてイズポピュラーとかイズアニバーサリーとか 評価メソッドだらけの開花したクラスになりがちです どちらもその場しのぎにはなっても長い目で見るとコードを複雑にするだけということですね ではどうすればいいのか そこで登場するのが使用スペシフィケーションパターンです これはあるオブジェクトが特定の条件を満たすかどうかを評価することだけを責務とした 完全に独立したオブジェクトを作るという考え方ですね 判断ロジックを丸ごと別のクラスに切り出すっていうことですか その通りですサークルフルスペシフィケーションというのがまさにそれです サークルが満員かどうかを判断するというあの複雑なロジックをこの新しいクラスに完全に 閉じ込めるんです なるほどこの使用クラスは内部でユーザーリポジトリを持つことが許されます でも元のサークルクラス自体はそうしたインフラの知識から完全に解放されて純粋な状態を保てるんですよ これはスッキリしますね コードを読む側からするとサークルフルスペシフィケーション.is satisfied by circle っていう一行を見るだけで ここでサークルが満員かどうかの複雑なチェックをしてるんだなっていう意図がすごく明確になります 判断基準という知識がきちんとカプセル化されている これは見通しがいい 関心ごとが綺麗に分離されますからね さらに資料ではこの使用オブジェクトがリポジトリに依存することすら避けたいという より純粋さを求める考え方も紹介されてますね ファーストクラスコレクションというアプローチです ファーストクラスコレクションつまりメンバーのリストをただの配列として渡すんじゃなくて サークルメンバー群というそれ自体がルールを持てる専用のオブジェクトにして渡す ということですね ご迷惑ですまさにその通り 判定に必要な情報をすべて含んだ値として使用オブジェクトに渡すことで 使用オブジェクトは外部への問い合わせが不要になって より純粋な判定機に徹することができるわけです なるほどいや奥が深いですね そして話はさらに展開します 今度はおすすめサークルを探したいという要求が出てきた 条件は設立1ヶ月以内でかつメンバーが10人以上 このおすすめかどうかというルールもまさに使用で表現できそうですね その通りですサークルレコメンドスペシフィケーションという使用オブジェクトを作ります そしてここからがこのパターンの非常に面白いところで その使用オブジェクトを今度はリポジトリに検索条件としてそのまま渡してしまうんです えっと使用を検索条件として使う この条件に合うものを探してきてとオブジェクトを丸ごと渡すんですか それは確かに綺麗ですね でもそれって裏側はどうなってるんですか まさか全部のサークルをメモリに読み込んでから一つずつフィルタリングするなんて非効率なことは 鋭い指摘です まさにその点がこのパターンの理想と現実のギャップを生む部分なんですよ まず理想的な側面から話すとコード上はリポジトリ.ファインドスペシフィケーションみたいに書けます このアプローチの美点はドメインの重要なルール つまり何がオススメなのかという知識がインフラ層であるリポジトリの実装の中に漏れ出すのを防げることです ああなるほど 普通ならファインドレコメンデッドサークルスみたいな専用のメソッドをリポジトリに作って その中に SQL のウェアークとかで設立1ヶ月以内でというロジックを直接書いちゃいがちですけど そうそう それだとドメインのルールがインフラ層のコードに埋もれてしまうんです まさにこの方法なら例えば今月最もメムラーが増えたサークルを探したくなっても モーストグロースサークルスペシフィケーションという新しい仕様クラスを作るだけで対応できる リポジトリのインターフェースは一切変更する必要がない 非常に拡張性が高い美しい設計です とここまでは理想の話ですよね 先ほどの僕の懸念に戻りますがこのエレガントな設計 現実のパフォーマンスは大丈夫なんでしょうか そこがこの話が本当に面白くなってくるところです ご指摘の通りこのファインドスペシフィケーションというメソッドを素朴に実装するとどうなるか データベースから全てのサークルのデータを一旦メモリー上に読み込んでから 一つ一つ使用オブジェクトでチェックしていくという動きになりがちです うわぁ やっぱり 全件取得してからのメモリ上でのフィルタリングですね データが数件ならいいですけどこれが数万数十万件になったらレスポンスは絶望的に遅くなりますね 美しい設計が現実のパフォーマンス要求に応えられないという典型的なジレンマだ ドメインのルールを綺麗に保ちたいでもユーザーが待たされるのは絶対に避けたい これ開発者にとっては本当に頭の痛い問題です そこで出てくるのがまあ現実的な落としどころです 資料ではこうしたパフォーマンスが非常に重要な読み取り処理に関しては ここまで築き上げてきたドメインモデルのルールを一旦脇に置いて専用の最適化された方法を提案しています ドメインモデルを使わないということですか 正確に言うと読み取り専用の別のモデル いわゆるリードモデルやクエリーサービスを用意するという考え方ですね 例えばサークルの一覧とそれぞれのオーナー名を表示する画面を考えてみてください ドメインモデルを愚直に使うとまずサークルをすべて取得し その後サークルごとにオーナーのユーザー情報を取得するというループ処理になりがちで いわゆる n プラス1問題ですね サークルが100件あったらデータベースへのクエリーが101回飛んでしまう これは本当に恐ろしい問題で開発中は数件のデータで動くからなかなか気づかないんです そしてリリースした途端ユーザーが1000人になった瞬間にサーバーが応答しなくなる よくある静かな時間爆弾ですね うわぁ そこでクエリーサービスではドメインオブジェクトを一つ一つ組み立てるんじゃなくて 画面表示に必要なデータだけを効率的に取得するために SQL のジョインクを駆使した専用のクエリを発行します あーなるほど これによりデータベースへの問い合わせはたった1回で済みます つまりデータを変更する時と読み取る時で使う道具も密通りも全く別にしてしまうわけですね これってデータを変更する処理コマンドと読み取る処理クエリを明確に分離するCQRSという考え方そのものですね その通りです データの整合性を厳密に守る必要のある複雑なドメインロジックはコマンド側に閉じ込める そして一覧表示のようなパフォーマンスが最優先されるクエリ側は表示速度を優先して最適化された専用の経路を用意する これは非常に実践的なアプローチです 弱さを遅らさるっていう これは魔法みたいで便利そうですけど ええ エンティティフレームワークのような特定の ORM がサポートしている強力な機能ですね ただ資料でも指摘されている通り これは特定の技術基盤に強く依存するということでもあります 将来的に技術基盤を変更する際の足枷になる可能性も考慮に入れる必要はありますね いや本当に今回の話は学びが多かったです 使用パターンという道具で複雑なビジネスルールをきれいに整理する方法から始まって それを検索に応用するエレガントな手法 そしてその先に待ち受けるパフォーマンスという現実的な壁 最後に CQRS という実践的な着地点まで 設計の理想から現実までを旅したような感覚です そうですね ドメインの純粋な表現を守りたいという設計上の理想と ユーザーに快適な体験を提供したいというパフォーマンス上の要求 この2つの間でどうバランスをとるかというのは ソフトウェア設計における永遠のテーマの1つなんです 使用パターンや CQRS といった考え方は その緊張関係をうまく管理していくための まあ 先人たちが積み重ねてきた知恵の結晶と言えるでしょう 最後に これを聞いているあなたに少し考えてみてほしいことがあります 資料では データを変更する処理 コマンドと 読み取る処理 クエリーを分ける話が出てきました あなたの身の回りにあるシステムやアプリを思い浮かべてみてください SNS に投稿するときの操作とタイムラインをただ眺めるときの操作は 裏側で求められるものが全く違うはずです もし最初からその2つを完全に別のものとして設計したら そのシステムは今とはどんな違う姿になるでしょうか