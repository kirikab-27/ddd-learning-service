import { Lesson, LessonTitle, MarkdownContent } from '@/domain/content/models';
import { LessonId } from '@/domain/shared';

// Lesson 1-1: なぜDDDが必要なのか
export const lesson1_1 = Lesson.create({
  id: LessonId.create('lesson-1-1'),
  title: LessonTitle.create('なぜDDDが必要なのか'),
  content: MarkdownContent.create(`
# なぜDDDが必要なのか

## 概要

このレッスンでは、DDDが解決しようとする問題と、DDDを採用するメリットについて学びます。
なぜ従来のソフトウェア開発アプローチでは複雑なビジネスロジックを扱うのが難しいのか、
そしてDDDがどのようにその課題を解決するのかを理解しましょう。

## ソフトウェア開発の課題

### 複雑なビジネスロジック

現代のソフトウェア開発では、ビジネスロジックが非常に複雑になることがあります。
例えば、ECサイトでは以下のような複雑なルールが存在します：

- 会員ランクによる割引率の違い
- 在庫状況に応じた注文制限
- 配送先による送料計算
- キャンペーン期間中の特別ルール

これらのルールが適切に整理されていないと、**スパゲッティコード**が生まれます。

\`\`\`typescript
// 悪い例：ビジネスルールが散在している
function processOrder(order, user, inventory) {
  let discount = 0;
  if (user.rank === 'gold') {
    discount = 0.1;
  } else if (user.rank === 'silver') {
    discount = 0.05;
  }
  // ...さらに多くの条件分岐が続く
}
\`\`\`

### 技術とビジネスの乖離

開発者が使う技術的な用語と、ビジネス側が使う用語が異なると、
コミュニケーションに齟齬が生まれます。

| ビジネス側の言葉 | 開発者の言葉 |
|----------------|------------|
| 「顧客」 | 「Userテーブル」 |
| 「注文を確定する」 | 「statusフラグを1にする」 |
| 「在庫を引き当てる」 | 「inventory -= quantity」 |

この乖離が大きくなると、ビジネス要件の誤解や実装ミスにつながります。

## DDDとは

**ドメイン駆動設計（Domain-Driven Design）** は、Eric Evansが2003年に提唱した
ソフトウェア設計手法です。

DDDの核心は：

> ソフトウェアの複雑さの根本原因は、**ドメイン（ビジネスの問題領域）** にある。
> したがって、ドメインを深く理解し、それをコードに反映させることが重要である。

### DDDの3つの柱

1. **ユビキタス言語**: ビジネスと開発で共通の言葉を使う
2. **モデル駆動設計**: ドメインモデルをコードの中心に据える
3. **境界づけられたコンテキスト**: 複雑さを適切な単位で分離する

## DDDのメリット

### 1. ビジネスと技術の共通理解

DDDでは、ビジネスエキスパートと開発者が同じ言葉（ユビキタス言語）を使います。

\`\`\`typescript
// DDDを適用した例：ビジネス用語がそのままコードに
class Order {
  confirm(): void {
    if (!this.canBeConfirmed()) {
      throw new OrderCannotBeConfirmedException();
    }
    this.status = OrderStatus.Confirmed;
  }
}
\`\`\`

### 2. 変更に強い設計

ドメインモデルを中心に設計することで、ビジネスルールの変更に柔軟に対応できます。

### 3. チームコミュニケーションの改善

共通言語があることで、要件定義の精度向上やコードレビューの効率化が実現します。

## まとめ

- **スパゲッティコード**や**ビジネスルールの散在**は、複雑なソフトウェア開発の大きな課題
- **技術とビジネスの乖離**は、コミュニケーションエラーや実装ミスを引き起こす
- **DDD**は、ドメインを中心に据えた設計手法で、これらの課題を解決する
- DDDにより、**共通理解**、**変更への強さ**、**コミュニケーション改善**が実現できる
`),
  order: 1,
});

// Lesson 1-2: ドメインエキスパートとの協業
export const lesson1_2 = Lesson.create({
  id: LessonId.create('lesson-1-2'),
  title: LessonTitle.create('ドメインエキスパートとの協業'),
  content: MarkdownContent.create(`
# ドメインエキスパートとの協業

## 概要

このレッスンでは、DDDにおけるドメインエキスパートとの協業について学びます。
なぜ協業が重要なのか、そして効果的なコミュニケーション手法について理解しましょう。

## ドメインエキスパートとは誰か

**ドメインエキスパート**とは、ビジネスドメインについて深い知識を持つ人のことです。
必ずしも「偉い人」や「肩書きのある人」ではありません。

ドメインエキスパートになりうる人：

| 役割 | 専門知識の例 |
|------|-----------|
| 営業担当者 | 顧客のニーズ、商談プロセス |
| カスタマーサポート | よくある問題、ユーザーの困りごと |
| 経理担当者 | 会計処理、請求ルール |
| 物流担当者 | 配送ルール、在庫管理 |

## なぜ協業が重要か

開発者がドキュメントを読んだだけでは、以下を把握できません：

- **暗黙のルール**: 「普通はこうする」という慣習
- **例外ケース**: 「でも、この場合は違う」というケース
- **優先度**: どのルールがより重要か
- **文脈**: なぜそのルールが存在するのか

## 効果的なコミュニケーション手法

### 1. イベントストーミング

**イベントストーミング**は、ビジネスプロセスを可視化するワークショップ手法です。

1. オレンジ色の付箋に「起きること（イベント）」を書く
2. 時系列に並べる
3. イベントを引き起こす「コマンド」と「アクター」を追加
4. 境界を見つけ、コンテキストを分離

### 2. ホワイトボードセッション

図を描きながらドメインエキスパートと対話する手法です。

### 3. プロトタイピング

実際に動くものを見せて、認識を合わせます。

## まとめ

- **ドメインエキスパート**は、ビジネスドメインの深い知識を持つ人
- 開発者だけでは**暗黙のルール**や**例外ケース**を把握できない
- **イベントストーミング**、**ホワイトボードセッション**、**プロトタイピング**が効果的
- 協業を通じて**ユビキタス言語**を構築し、コードに反映させる
`),
  order: 2,
});

// Lesson 1-3: ドメインモデルの役割
export const lesson1_3 = Lesson.create({
  id: LessonId.create('lesson-1-3'),
  title: LessonTitle.create('ドメインモデルの役割'),
  content: MarkdownContent.create(`
# ドメインモデルの役割

## 概要

このレッスンでは、DDDの中核となる「ドメインモデル」について学びます。
モデルとは何か、なぜ重要なのか、そしてどのように表現するのかを理解しましょう。

## モデルとは何か

**モデル**とは、現実世界の複雑さを目的に応じて簡略化した表現です。

モデルの例：
- **地図**: 現実の地形を2次元に簡略化
- **組織図**: 会社の構造を階層的に表現
- **ER図**: データベースの構造を表現

重要なのは、モデルは**現実の完全なコピーではない**ということです。

## ドメインモデルの目的

### 1. 複雑さの整理

ビジネスの複雑さを、理解可能なレベルに整理します。

\`\`\`typescript
// モデルあり：概念が整理されている
class Payment {
  constructor(
    private readonly order: Order,
    private readonly amount: Money,
    private readonly method: PaymentMethod
  ) {}

  execute(): PaymentResult {
    this.validateAmount();
    return this.method.process(this.amount);
  }
}
\`\`\`

### 2. コミュニケーションの基盤

ドメインモデルは、チーム全員が参照できる**共通の理解**を提供します。

### 3. 設計の指針

モデルがあることで、ロジックの配置や概念の分離が判断しやすくなります。

## モデルの表現方法

### 1. UML図

クラス図でドメインモデルを視覚化します。全体像を俯瞰でき、非エンジニアにも伝わりやすいです。

### 2. コード

コード自体がドメインモデルの最も正確な表現です。

\`\`\`typescript
class Order {
  private readonly id: OrderId;
  private items: OrderItem[];
  private status: OrderStatus;

  addItem(product: Product, quantity: number): void {
    if (this.status !== OrderStatus.Draft) {
      throw new CannotModifyConfirmedOrderError();
    }
    const item = OrderItem.create(product, quantity);
    this.items.push(item);
  }

  confirm(): void {
    if (this.items.length === 0) {
      throw new EmptyOrderCannotBeConfirmedError();
    }
    this.status = OrderStatus.Confirmed;
  }
}
\`\`\`

### 3. 用語集（ユビキタス言語）

ドメインの言葉を定義した辞書です。誰でも読め、認識のズレを防ぎます。

## まとめ

- **モデル**は現実を目的に応じて簡略化した表現
- **ドメインモデル**はビジネスドメインの概念、関係、ルールを表現する
- ドメインモデルは**複雑さの整理**、**コミュニケーションの基盤**、**設計の指針**として機能する
- 表現方法には**UML図**、**コード**、**用語集**があり、それぞれ補完し合う
- モデルは**継続的に改善**されるべきもの
`),
  order: 3,
});

export const chapter1Lessons = [lesson1_1, lesson1_2, lesson1_3];

// =============================================================================
// Chapter 2: ユビキタス言語
// =============================================================================

// Lesson 2-1: ユビキタス言語とは
export const lesson2_1 = Lesson.create({
  id: LessonId.create('lesson-2-1'),
  title: LessonTitle.create('ユビキタス言語とは'),
  content: MarkdownContent.create(`
# ユビキタス言語とは

## 概要

このレッスンでは、DDDの核心概念である「ユビキタス言語」について学びます。
ユビキタス言語とは何か、なぜ重要なのか、そしてどのような特徴を持つのかを理解しましょう。

## ユビキタス言語の定義

**ユビキタス言語（Ubiquitous Language）** とは、プロジェクトに関わる全員が使う共通のドメイン言語です。

### チーム全員が使う共通言語

ユビキタス言語は以下の人々が共通して使用します：

| 立場 | 使用場面 |
|------|---------|
| ドメインエキスパート | 要件の説明、業務の相談 |
| 開発者 | コードの実装、設計の議論 |
| プロジェクトマネージャー | 仕様書の作成、進捗報告 |
| QAエンジニア | テストケースの作成 |

### ドメインエキスパートと開発者の橋渡し

\`\`\`
ドメインエキスパート ←→ ユビキタス言語 ←→ 開発者
       ↓                    ↓                ↓
    業務知識              共通理解            コード
\`\`\`

## 言語の不一致による問題

ユビキタス言語がない場合、以下のような問題が発生します。

### 1. コミュニケーションエラー

\`\`\`
ビジネス: 「顧客を凍結して」
開発者A: 「アカウントを無効化すればいいんだな」
開発者B: 「いや、ログインを一時停止するだけでは？」
→ 実装がバラバラになる
\`\`\`

### 2. 実装ミス

言葉の解釈が異なると、ビジネスの意図と異なるコードが書かれます。

\`\`\`typescript
// ビジネスの意図：「注文をキャンセルする」＝在庫を戻し、決済を取り消す
// 開発者の解釈：削除フラグを立てるだけ
function cancelOrder(orderId: string) {
  db.orders.update(orderId, { deleted: true }); // 不完全な実装
}
\`\`\`

### 3. ドキュメントとコードの乖離

\`\`\`
仕様書: 「ユーザー」
コード: User, Customer, Account, Member が混在
→ どれが何を指すのか分からない
\`\`\`

## ユビキタス言語の特徴

### 1. ドメイン固有

ユビキタス言語は、その事業ドメインに特化した言葉です。

\`\`\`typescript
// ECサイトのユビキタス言語
class ShoppingCart { ... }  // 買い物かご
class Checkout { ... }      // 購入手続き
class Shipment { ... }      // 出荷

// 医療システムのユビキタス言語
class Patient { ... }       // 患者
class Prescription { ... }  // 処方箋
class Diagnosis { ... }     // 診断
\`\`\`

### 2. 進化する

ビジネスの理解が深まるにつれて、ユビキタス言語も進化します。

\`\`\`
初期: 「ユーザー」
  ↓ ビジネスの理解が深まる
中期: 「会員」と「ゲスト」に分離
  ↓ さらに詳細化
後期: 「プレミアム会員」「一般会員」「ゲスト」
\`\`\`

### 3. コードに反映される

ユビキタス言語はドキュメントだけでなく、コードにも反映されます。

\`\`\`typescript
// 良い例：ユビキタス言語がそのままコードに
class Order {
  confirm(): void { ... }      // 「注文を確定する」
  cancel(): void { ... }       // 「注文をキャンセルする」
  requestRefund(): void { ... } // 「返金を依頼する」
}
\`\`\`

## まとめ

- **ユビキタス言語**は、チーム全員が使う共通のドメイン言語
- 言語の不一致は、**コミュニケーションエラー**、**実装ミス**、**ドキュメントとコードの乖離**を引き起こす
- ユビキタス言語は**ドメイン固有**で、**進化**し、**コードに反映**される
`),
  order: 1,
});

// Lesson 2-2: チームで共通言語を作る
export const lesson2_2 = Lesson.create({
  id: LessonId.create('lesson-2-2'),
  title: LessonTitle.create('チームで共通言語を作る'),
  content: MarkdownContent.create(`
# チームで共通言語を作る

## 概要

このレッスンでは、ユビキタス言語をチームで構築する方法について学びます。
用語集の作成、モデリングワークショップ、言語の洗練プロセスを理解しましょう。

## 用語集の作成

### 用語の定義方法

用語集には以下の要素を含めます：

| 項目 | 説明 | 例 |
|------|-----|-----|
| 用語 | ドメインで使う言葉 | 「注文」 |
| 定義 | 用語の明確な意味 | 顧客が商品を購入する意思表示 |
| 同義語 | 同じ意味で使われる言葉 | オーダー、発注 |
| 反例 | この用語に含まれないもの | 見積り依頼は含まない |
| コード表現 | コードでの表現 | \`Order\` クラス |

\`\`\`markdown
## 用語集の例

### 注文（Order）
**定義**: 顧客が1つ以上の商品を購入する意思を示したもの

**同義語**: オーダー
**反例**: 見積り依頼、問い合わせは含まない

**状態**:
- 下書き（Draft）: 作成中、変更可能
- 確定済み（Confirmed）: 確定後、変更不可
- キャンセル（Cancelled）: 取り消し済み

**コード**: \`class Order\`
\`\`\`

### 用語集の管理・更新

- **バージョン管理**: Gitで用語集を管理し、変更履歴を追跡
- **レビュープロセス**: 用語の追加・変更時はチームでレビュー
- **定期的な見直し**: スプリントレトロスペクティブで用語集を確認

## モデリングワークショップ

### ドメインエキスパートとの対話

効果的な質問の例：

\`\`\`
開発者: 「『注文をキャンセルする』とは具体的にどういうことですか？」
ドメインエキスパート: 「在庫を戻して、決済を取り消して、顧客に通知を送ることです」
開発者: 「決済が既に完了している場合は？」
ドメインエキスパート: 「その場合は『返金処理』になります」
\`\`\`

### ホワイトボードセッション

1. **概念の可視化**: 主要な概念を付箋やボックスで表現
2. **関係の明確化**: 概念間の関係を矢印で結ぶ
3. **境界の発見**: 異なるコンテキストを色分けで表現

\`\`\`
┌─────────────┐      ┌─────────────┐
│    顧客     │──────│    注文     │
│  Customer   │ 作成 │   Order     │
└─────────────┘      └──────┬──────┘
                            │ 含む
                     ┌──────┴──────┐
                     │   注文明細   │
                     │  OrderItem  │
                     └─────────────┘
\`\`\`

## 言語の洗練プロセス

### 曖昧さの排除

\`\`\`
曖昧な表現:「商品」
  ↓ 質問：「商品」は何を指しますか？
洗練後:
  - Product: カタログに載っている商品マスタ
  - OrderItem: 注文に含まれる商品（数量付き）
  - InventoryItem: 倉庫にある在庫
\`\`\`

### コンテキストの明確化

同じ言葉でも、コンテキストによって意味が異なることがあります：

\`\`\`
「顧客」という言葉の意味:
- 営業コンテキスト: 見込み客から既存顧客まで
- 配送コンテキスト: 届け先の住所を持つ人
- 請求コンテキスト: 支払い責任者
\`\`\`

それぞれのコンテキストで適切な名前を定義します：

\`\`\`typescript
// 営業コンテキスト
class Lead { ... }      // 見込み客
class Customer { ... }  // 既存顧客

// 配送コンテキスト
class Recipient { ... } // 届け先

// 請求コンテキスト
class Payer { ... }     // 支払い者
\`\`\`

## まとめ

- **用語集**は用語、定義、同義語、反例、コード表現を含め、バージョン管理する
- **モデリングワークショップ**では、ドメインエキスパートとの対話とホワイトボードセッションを活用
- **言語の洗練**では、曖昧さを排除し、コンテキストを明確化する
- ユビキタス言語は**継続的に進化**させていくもの
`),
  order: 2,
});

// Lesson 2-3: コードに反映する
export const lesson2_3 = Lesson.create({
  id: LessonId.create('lesson-2-3'),
  title: LessonTitle.create('コードに反映する'),
  content: MarkdownContent.create(`
# コードに反映する

## 概要

このレッスンでは、ユビキタス言語をコードに反映する方法について学びます。
命名規則、コード例の比較、リファクタリングの手法を理解しましょう。

## 命名規則

### クラス名の付け方

ドメインの概念をそのままクラス名にします：

\`\`\`typescript
// 良い例：ユビキタス言語をそのまま使用
class Order { }         // 注文
class Customer { }      // 顧客
class ShoppingCart { }  // 買い物かご
class Shipment { }      // 出荷

// 悪い例：技術的な命名
class OrderData { }     // 「Data」は不要
class CustomerInfo { }  // 「Info」は曖昧
class CartManager { }   // 「Manager」は責務が不明確
\`\`\`

### メソッド名の付け方

ビジネスアクションをそのままメソッド名にします：

\`\`\`typescript
class Order {
  // 良い例：ビジネスの言葉
  confirm(): void { }       // 「注文を確定する」
  cancel(): void { }        // 「注文をキャンセルする」
  requestRefund(): void { } // 「返金を依頼する」

  // 悪い例：技術的な言葉
  setStatus(): void { }     // 何のステータス？
  process(): void { }       // 何を処理？
  update(): void { }        // 何を更新？
}
\`\`\`

### ドメイン用語をそのまま使う

ドメインエキスパートが使う言葉を、そのままコードに反映します：

\`\`\`typescript
// ドメインエキスパートの言葉
// 「在庫を引き当てる」「出荷指示を出す」「配送完了を記録する」

class Inventory {
  allocate(orderId: OrderId, quantity: number): Allocation {
    // 在庫を引き当てる
  }
}

class Warehouse {
  issueShipmentInstruction(order: Order): ShipmentInstruction {
    // 出荷指示を出す
  }
}

class Delivery {
  recordCompletion(shipmentId: ShipmentId): void {
    // 配送完了を記録する
  }
}
\`\`\`

## コード例

### ユビキタス言語を反映したコード

\`\`\`typescript
// 用語集:
// - 注文（Order）: 顧客が商品を購入する意思表示
// - 確定する（confirm）: 注文を変更不可にする
// - キャンセルする（cancel）: 注文を取り消す

class Order {
  private status: OrderStatus;
  private items: OrderItem[];

  confirm(): void {
    if (this.items.length === 0) {
      throw new EmptyOrderCannotBeConfirmedError();
    }
    if (this.status !== OrderStatus.Draft) {
      throw new OrderAlreadyConfirmedError();
    }
    this.status = OrderStatus.Confirmed;
  }

  cancel(): void {
    if (this.status === OrderStatus.Shipped) {
      throw new ShippedOrderCannotBeCancelledError();
    }
    this.status = OrderStatus.Cancelled;
  }
}
\`\`\`

### 反映されていないコードとの比較

\`\`\`typescript
// 悪い例：ユビキタス言語が反映されていない
class OrderService {
  processOrder(data: OrderData): void {
    if (data.items.length === 0) {
      throw new Error('Items required');
    }
    data.status = 1; // マジックナンバー
    db.save(data);
  }

  updateOrderStatus(id: string, status: number): void {
    const data = db.find(id);
    data.status = status;
    db.save(data);
  }
}

// 良い例：ユビキタス言語が反映されている
class Order {
  confirm(): void {
    this.ensureNotEmpty();
    this.ensureDraft();
    this.status = OrderStatus.Confirmed;
  }

  private ensureNotEmpty(): void {
    if (this.items.length === 0) {
      throw new EmptyOrderCannotBeConfirmedError();
    }
  }
}
\`\`\`

## リファクタリング

### 既存コードへの適用方法

1. **用語の洗い出し**: コード内の命名を一覧化
2. **用語集との照合**: ユビキタス言語と比較
3. **リネーム**: 段階的に命名を変更

\`\`\`typescript
// Step 1: 現状の確認
class UserData {
  updateStatus(s: number): void { }
}

// Step 2: クラス名の変更
class Customer {  // UserData → Customer
  updateStatus(s: number): void { }
}

// Step 3: メソッド名の変更
class Customer {
  activate(): void { }  // updateStatus → activate（有効化する）
  suspend(): void { }   // updateStatus → suspend（一時停止する）
}

// Step 4: パラメータの明確化
class Customer {
  activate(): void {
    this.status = CustomerStatus.Active;
  }
  suspend(reason: SuspensionReason): void {
    this.status = CustomerStatus.Suspended;
    this.suspensionReason = reason;
  }
}
\`\`\`

### 段階的なリファクタリング

大きな変更は避け、小さな変更を積み重ねます：

1. **テストを書く**: 現状の動作を保証
2. **命名を変更**: IDEのリファクタリング機能を活用
3. **テストを実行**: 動作が変わっていないことを確認
4. **コミット**: 小さな単位でコミット

## まとめ

- **クラス名**はドメインの概念を、**メソッド名**はビジネスアクションをそのまま表現
- 技術的な命名（Data, Info, Manager, process, update）を避け、**ドメイン用語をそのまま使う**
- **リファクタリング**は段階的に行い、テストで動作を保証しながら進める
- コードがユビキタス言語を反映することで、**可読性**と**保守性**が向上する
`),
  order: 3,
});

export const chapter2Lessons = [lesson2_1, lesson2_2, lesson2_3];

// =============================================================================
// Chapter 3: 境界づけられたコンテキスト
// =============================================================================

// Lesson 3-1: コンテキストとは何か
export const lesson3_1 = Lesson.create({
  id: LessonId.create('lesson-3-1'),
  title: LessonTitle.create('コンテキストとは何か'),
  content: MarkdownContent.create(`
# コンテキストとは何か

## 概要

このレッスンでは、DDDの重要な概念である「境界づけられたコンテキスト」について学びます。
コンテキストとは何か、なぜ境界が必要なのかを理解しましょう。

## 境界づけられたコンテキストの定義

**境界づけられたコンテキスト（Bounded Context）** とは、特定のドメインモデルとユビキタス言語が
一貫して適用される明確な境界を持つ領域です。

### モデルが適用される範囲

\`\`\`
┌─────────────────────────────────────────┐
│       境界づけられたコンテキスト          │
│  ┌─────────────────────────────────┐   │
│  │      ドメインモデル              │   │
│  │  ・エンティティ                  │   │
│  │  ・値オブジェクト                │   │
│  │  ・ドメインサービス              │   │
│  └─────────────────────────────────┘   │
│  ┌─────────────────────────────────┐   │
│  │      ユビキタス言語              │   │
│  │  用語A, 用語B, 用語C...          │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
\`\`\`

### 言語の一貫性が保たれる領域

コンテキスト内では、同じ言葉は常に同じ意味を持ちます：

\`\`\`typescript
// 販売コンテキスト内では「商品」は一貫した意味
class Product {
  private price: Money;
  private name: ProductName;
  private description: ProductDescription;
}
\`\`\`

## 境界の意味

### なぜ境界が必要か

1. **言語の衝突を防ぐ**: 同じ言葉が異なる意味を持つことを避ける
2. **複雑さの分離**: システムを管理可能な単位に分割
3. **チームの自律性**: 各チームが独立して開発可能

### 境界がないとどうなるか

\`\`\`
境界がない場合:

「商品」という言葉が曖昧に
     ↓
┌──────────────────────────────────────────┐
│  Product クラスが肥大化                   │
│  - カタログ情報                           │
│  - 在庫情報                               │
│  - 配送情報                               │
│  - 価格情報                               │
│  → 責務が不明確、変更が困難               │
└──────────────────────────────────────────┘
\`\`\`

## コンテキストの例

### ECサイトの例

ECサイトは複数のコンテキストで構成されます：

| コンテキスト | 責務 | 「商品」の意味 |
|-------------|------|--------------|
| カタログ | 商品の表示・検索 | 名前、説明、画像 |
| 在庫 | 在庫の管理 | SKU、在庫数、倉庫位置 |
| 注文 | 注文の処理 | 注文明細、数量、単価 |
| 配送 | 配送の管理 | 重量、サイズ、配送先 |

### 同じ「商品」でも意味が異なる

\`\`\`typescript
// カタログコンテキスト
class CatalogProduct {
  name: string;
  description: string;
  images: Image[];
  categories: Category[];
}

// 在庫コンテキスト
class InventoryItem {
  sku: string;
  quantity: number;
  warehouseLocation: Location;
  reorderPoint: number;
}

// 配送コンテキスト
class ShippableItem {
  weight: Weight;
  dimensions: Dimensions;
  handlingInstructions: string;
}
\`\`\`

これらは全て「商品」に関するものですが、各コンテキストで異なるモデルとして表現されます。

## まとめ

- **境界づけられたコンテキスト**は、モデルとユビキタス言語が一貫して適用される範囲
- 境界により**言語の衝突**を防ぎ、**複雑さを分離**し、**チームの自律性**を確保
- 同じ概念（例：商品）でも、コンテキストによって**異なるモデル**で表現される
`),
  order: 1,
});

// Lesson 3-2: コンテキストの見つけ方
export const lesson3_2 = Lesson.create({
  id: LessonId.create('lesson-3-2'),
  title: LessonTitle.create('コンテキストの見つけ方'),
  content: MarkdownContent.create(`
# コンテキストの見つけ方

## 概要

このレッスンでは、システムから境界づけられたコンテキストを見つける方法について学びます。
分析パターンと境界の決め方を理解しましょう。

## 分析パターン

### 言語の違いに注目する

同じ言葉が異なる意味で使われている場所を探します：

\`\`\`
「顧客」という言葉の使われ方:

営業チーム: 「顧客の連絡先を更新して」
  → 会社名、担当者名、電話番号

経理チーム: 「顧客の与信限度額を確認して」
  → 支払い履歴、与信情報

配送チーム: 「顧客の届け先を確認して」
  → 住所、配送時間帯

→ 3つの異なるコンテキストが存在する可能性
\`\`\`

### ビジネスプロセスの境界

ビジネスプロセスの切れ目を探します：

\`\`\`
ECサイトの注文プロセス:

[カタログ閲覧] → [カートに追加] → [注文確定] → [決済] → [在庫引当] → [配送]
     ↑              ↑              ↑         ↑         ↑          ↑
   カタログ        カート         注文       決済      在庫        配送
  コンテキスト   コンテキスト   コンテキスト コンテキスト コンテキスト コンテキスト
\`\`\`

### チーム構造との関連

**コンウェイの法則**: 組織構造がシステム構造に影響を与える

\`\`\`
チーム構造:
├── フロントエンドチーム → カタログコンテキスト
├── 注文処理チーム → 注文・決済コンテキスト
├── 物流チーム → 在庫・配送コンテキスト
└── 顧客管理チーム → 顧客コンテキスト
\`\`\`

チームの責任範囲がコンテキストの境界のヒントになります。

## 境界の決め方

### 大きすぎず、小さすぎず

\`\`\`
❌ 大きすぎる:
┌─────────────────────────────────────────┐
│           EC システム全体               │
│  カタログ + 在庫 + 注文 + 決済 + 配送    │
│  → 複雑すぎて管理困難                   │
└─────────────────────────────────────────┘

❌ 小さすぎる:
┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐
│商品名  │ │商品価格│ │在庫数  │ │カテゴリ│
└────────┘ └────────┘ └────────┘ └────────┘
→ 過度に分割され、連携コストが増大

✅ 適切なサイズ:
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│  カタログ    │ │    在庫     │ │    注文     │
│ コンテキスト │ │ コンテキスト │ │ コンテキスト │
└─────────────┘ └─────────────┘ └─────────────┘
→ 独立して開発・デプロイ可能な単位
\`\`\`

### 変更の頻度

頻繁に一緒に変更されるものは同じコンテキストに：

\`\`\`
変更の分析:
- 価格変更 → カタログの価格表示も変更 → 同じコンテキスト
- 在庫ロジック変更 → 配送は影響なし → 別のコンテキスト
\`\`\`

### チームの責任範囲

\`\`\`typescript
// 良い境界: 1つのチームが責任を持てる範囲
// 注文コンテキスト（注文チームが担当）
class Order { }
class OrderItem { }
class OrderStatus { }
class OrderRepository { }

// 悪い境界: 複数チームが関わる範囲を1つに
// 何でもコンテキスト（誰が責任者？）
class Order { }
class Inventory { }
class Payment { }
class Shipping { }
\`\`\`

## コンテキスト発見のワークショップ

### イベントストーミングの活用

1. **ドメインイベント**を洗い出す
2. **コマンド**と**アクター**を追加
3. **集約**を特定する
4. **境界**を引く

\`\`\`
[注文が作成された] [支払いが完了した] [商品が出荷された]
        ↓                  ↓                  ↓
    注文コンテキスト    決済コンテキスト    配送コンテキスト
\`\`\`

## まとめ

- **言語の違い**、**ビジネスプロセスの境界**、**チーム構造**に注目してコンテキストを見つける
- 境界は**大きすぎず、小さすぎず**、独立して開発・デプロイ可能な単位に
- **変更の頻度**と**チームの責任範囲**を考慮して境界を決める
- **イベントストーミング**はコンテキスト発見に有効なワークショップ手法
`),
  order: 2,
});

// Lesson 3-3: コンテキスト間の関係
export const lesson3_3 = Lesson.create({
  id: LessonId.create('lesson-3-3'),
  title: LessonTitle.create('コンテキスト間の関係'),
  content: MarkdownContent.create(`
# コンテキスト間の関係

## 概要

このレッスンでは、境界づけられたコンテキスト間の関係性について学びます。
上流/下流の関係と、主要な統合パターンを理解しましょう。

## 上流/下流の関係

### 上流コンテキストが下流に影響

\`\`\`
上流（Upstream）             下流（Downstream）
┌─────────────┐              ┌─────────────┐
│   注文      │ ──────────→ │   配送      │
│ コンテキスト │   注文情報   │ コンテキスト │
└─────────────┘              └─────────────┘

上流の変更 → 下流に影響
下流の変更 → 上流に影響なし
\`\`\`

### 依存関係の方向

\`\`\`typescript
// 下流（配送コンテキスト）は上流（注文コンテキスト）に依存
class ShippingService {
  // 注文コンテキストのイベントを購読
  handleOrderConfirmed(event: OrderConfirmedEvent): void {
    const shipment = this.createShipmentFromOrder(event.orderId);
    this.shipmentRepository.save(shipment);
  }
}
\`\`\`

## 統合パターン

### 1. 共有カーネル（Shared Kernel）

2つのコンテキストが共通のモデルを共有するパターン：

\`\`\`
┌─────────────┐  共有部分  ┌─────────────┐
│ コンテキストA │◀────────▶│ コンテキストB │
└─────────────┘           └─────────────┘
         ↓
   ┌─────────────┐
   │ 共有カーネル │
   │ - Money     │
   │ - Address   │
   └─────────────┘
\`\`\`

**使用場面**: 密接に連携するチーム間で、共通の概念を共有したい場合

\`\`\`typescript
// 共有カーネル（shared-kernel パッケージ）
export class Money {
  constructor(
    private readonly amount: number,
    private readonly currency: Currency
  ) {}
}

// 両方のコンテキストで使用
import { Money } from '@shared-kernel';
\`\`\`

**注意点**: 変更時は両チームの合意が必要。乱用するとコンテキストの独立性が失われる。

### 2. 腐敗防止層（Anti-Corruption Layer）

外部システムやレガシーシステムとの統合時に、自分のモデルを守るパターン：

\`\`\`
┌─────────────┐   ┌─────────────┐   ┌─────────────┐
│ 外部/レガシー │ → │ 腐敗防止層  │ → │ 自コンテキスト│
│  システム    │   │    (ACL)    │   │             │
└─────────────┘   └─────────────┘   └─────────────┘
                        ↓
                  翻訳・変換
\`\`\`

\`\`\`typescript
// 腐敗防止層（ACL）
class CustomerTranslator {
  // 外部システムのデータを自分のモデルに変換
  translateFromLegacy(legacyCustomer: LegacyCustomerData): Customer {
    return Customer.create({
      id: CustomerId.create(legacyCustomer.CUST_NO),
      name: CustomerName.create(
        legacyCustomer.FIRST_NM + ' ' + legacyCustomer.LAST_NM
      ),
      email: Email.create(legacyCustomer.EMAIL_ADDR),
    });
  }
}
\`\`\`

**使用場面**: レガシーシステムとの統合、外部APIとの連携

### 3. 公開ホストサービス（Open Host Service）

他のコンテキストに対して、明確なAPIを公開するパターン：

\`\`\`
              公開API
┌─────────────┐  REST/gRPC  ┌─────────────┐
│ 提供者      │ ────────── │ 消費者A     │
│ コンテキスト │ ────────── │ 消費者B     │
│             │ ────────── │ 消費者C     │
└─────────────┘             └─────────────┘
\`\`\`

\`\`\`typescript
// 公開ホストサービス（REST API）
@Controller('/orders')
class OrderController {
  @Get('/:id')
  async getOrder(@Param('id') id: string): Promise<OrderDTO> {
    const order = await this.orderRepository.findById(id);
    return this.toDTO(order);  // 公開形式に変換
  }
}
\`\`\`

**使用場面**: 複数のコンテキストに同じサービスを提供する場合

## パターン選択の指針

| 状況 | 推奨パターン |
|------|------------|
| 密接に連携するチーム | 共有カーネル |
| レガシーシステム統合 | 腐敗防止層 |
| 外部API連携 | 腐敗防止層 |
| 複数コンテキストへのサービス提供 | 公開ホストサービス |
| チーム間の独立性重視 | 腐敗防止層 + 公開ホストサービス |

## コンテキストマップ

コンテキスト間の関係を図示したものが**コンテキストマップ**です：

\`\`\`
           ┌─────────┐
           │ カタログ │
           └────┬────┘
                │ 公開API
           ┌────▼────┐      ┌─────────┐
           │  注文   │ ───→ │  配送   │
           └────┬────┘ 上流  └─────────┘
                │            下流
           ┌────▼────┐
           │  決済   │←─── 外部決済システム
           └─────────┘ ACL
\`\`\`

## まとめ

- コンテキスト間には**上流/下流**の依存関係がある
- **共有カーネル**は共通モデルを共有（密接なチーム向け）
- **腐敗防止層**は外部の影響から自分のモデルを守る
- **公開ホストサービス**は明確なAPIを他コンテキストに提供
- **コンテキストマップ**でシステム全体の関係を可視化
`),
  order: 3,
});

export const chapter3Lessons = [lesson3_1, lesson3_2, lesson3_3];
