今回のテーマはですねドメイン駆動設計におけるアプリケーションサービスです ソフトウェアの機能を実装するときビジネスのコアなルールとそれを呼び出すための 手続き的なコードが何かこう同じ場所にぐちゃっと書かれてしまうこと よくありますよね あとからこの仕様変更8どこを直せばいいんだっけって 高度の海をさまようハメになった経験 あなたにもありませんか 今回深掘りする資料はまさにその悩みを解決するための設計パターンに光を当てて います ドメインの心臓部をどう守ってユーザーの要求 つまりユースケースをどうきれいに実現するのか その全体の流れを司るまあ指揮者ともいえるアプリケーションサービスの役割を sns のユーザー機能っていう身近な例で具体的に解き明かしていきましょう 指揮者良い例えですね まさにその通りでドメインオブジェクト つまりエンティティとか値オブジェクトといった個々の落談員たちだけでは一つのまとまった曲 つまりユーザーの要求を演奏することはできないんですよ アプリケーションサービスという指揮者がタクトを振って初めて意味のある一連の処理 つまりユースケースが完成するんです なのでどこまでが指揮者の仕事でどこからが落談員の専門領域なのか その境界線をはっきりさせることがすごく重要になりますね なるほどでは早速その指揮者の正体に迫っていきましょうか 資料ではユースケースを実現するオブジェクトと定義されてますけど これってつまりユーザーがアカウントを登録したいとか名前を変えたいとか そういう一つ一つのやりたいことをシステムの中で担当する窓口 みたいな理解でいいんでしょうか はいその通りですそして面白いのが資料のドメインオブジェクトを組み合わせて実行する スクリプトのような振る舞いっていう表現 あーありましたね主役はあくまで落談員であるドメインオブジェクトたちなんです アプリケーションサービスは彼らの能力を適切な順番で呼び出すだけの まあ薄いスクリプトであるべきっていう思想がここに込められてるんですね ここで一つ疑問が湧くんですが以前取り上げたドメインサービスとは何が違うんでしょう どちらもサービスってつくのでちょっと混同してしまいそうです ああはいはい非常に良い質問です そこが最初の関門ですからね簡単に言うとあの関心事のレイヤーが違います レイヤーですか ドメインサービスが扱うのはビジネスの世界のルールそのものなんです ルールそのものはいユーザー名はシステム

アイテム全体でユニークでなければならない、というような普遍的な知識ですね。 これはアプリケーションの都合とは関係なく、ビジネスとして存在するルールです。 ふんふん。一方で、アプリケーションサービスは? アプリケーションサービスが扱うのは、アプリケーションとしての都合ですね。 例えば、ウェブフォームから送られてきたユーザー名とメールアドレスを受け取って、 まず、ドメインサービスに重複がないか確認してもらい、 OKならリポジトリを使ってデータベースに保存して、 最後に登録完了という結果を返す、といった一連の段取り。 これって純粋なビジネスルールじゃなくて、 このアプリケーションを動かすための手順、つまりユースケースそのものなんですよ。 なるほど。ドメインサービスはルールの専門家で、 アプリケーションサービスは仕事の段取り屋、という感じですね。 役割分担がすごくクリアになりました。 理屈は分かりましたけど、これを実際のコードに落とし込むとどういう姿になるんでしょうか。 いいですね。実践に移りましょう。 資料にあるSNSのユーザー機能、いわゆるCRUD処理を組み立てる過程を体験するのが一番分かりやすいでしょう。 まずは基本のユーザー登録、クリエイト処理から見ていきましょうか。 資料のリスト6.5のコードですね。 ユーザーオブジェクトを作って、ユーザーサービス、これがドメインサービスですね。 それで、乗服をチェックしてリポジトリで保存する、と。 驚くほどシンプルですね。ただの命令の並べきに見えます。 そうなんです。そして、ここで資料が面白い指摘をしているんです。 このコード、どこかで見た記憶がありませんか?と。 え? 実は、以前のショーで私たちが何気なく書いていたコンソールアプリケーションのプログラムクラスのメイン処理。 あれがまさにアプリケーションサービスの原型だったんですよ。 うわ、ほんとだ。 私たちは知らないうちに、もう指揮者を書いていたんですね。 それは面白い。なんか伏線回収みたいですごく腑に落ちました。 では次に、情報の取得、リード処理ですね。 ユーザーデータを返すだけの処理ですけど、ここにDTOのジレンマという罠があると。 そうなんです。取得したユーザーオブジェクト、つまりドメインの心臓部ともいえるエンティティを、そのままUI層に返してしまっていいのか、という問題です。 手っ取り早いのはもちろんそのまま返す方法。実装は1行で済みますからね。 でも資料のリスト6.7が示すように、これは非常に危険な行為なんです。 危険ですか。具体的に何が問題なんでしょう。 ユーザーオブジェクトには、チェンジネームのような、自身の状態を変更するメソッドが備わっていますよね。 はい、ありますね。

これを直接UI層に渡してしまうと 本来アプリケーションサービスという正規の窓口を通さなければ 実行できないはずのドメインのモジックが UI側のボタンクリック一つで どこからでも呼び出せてしまう状態になるんです あーなるほど もちろんリポジトリで保存しない限りデータは永続化されませんが ドメインのルールがアプリケーションのあちこちに漏れ出して 管理不可能になる第一歩です なるほど 落をしたつもりが後でとんでもない困難を招くと ではどうすればいいんですか? そこで登場するのがDTO データトランスファーオブジェクトです はい これはリスト6.8のユーゾデータクラスのように ロジックを持たない単なるデータの入れ物です ドメインオブジェクトから必要な情報だてを このDTOにコピーして UI層にはこちらを渡すんです まあひとまかかかりますけど これによりドメインオブジェクトは内部に隠蔽されて 安全に保たれるわけです でも正直これって少し面倒に感じません? ユーザークラスにプロパティが20個あったら DTOに20個プロパティを定義して 一つ一つ値をコピーするって ただの退屈な作業に思えちゃいます その気持ちはすごくよくわかります しかしそのひとまが将来のシステムの保守性を 劇的に向上させるんですよ それに資料はもっと洗練された方法も示唆していて ほう リスト6.11や6.12のように DTOのコンストラクタにドメインオブジェクト自身を渡して データ打ち替えのロジックを DTOの内部にカプセル化してしまうんです こうすれば将来ユーザークラスに項目が増えても 修正はユーザーデータクラスの コンストラクタ一箇所で済みますから 面倒な作業を賢く一箇所にまとめるわけですね なるほど面倒なりぬ工夫があると納得しました では次に情報の更新アップデート処理です ここでもまた別の問題が出てきますね 更新項目が増えるたびに メソッドの引数が増えていく問題 リスト6.16はまさにその例で 名前とメールアドレスを更新するメソッドが示されていますが もし自己紹介文とか誕生日も更新したくなったら 引数がどんどん増えていく その通りです それに名前だけ更新したい場合と メールアドレスだけ更新したい場合で 別々のメソッドを用意し始めると あっという間にメソッドだらけになってしまいます この解決策がコマンドオブジェクトですね はい リスト6.17のユーザーアップデートコマンドのように 更新に必要なデータを全部詰め込んだオブジェクトを一つ作って それを丸ごと引数として渡してしまう リスト6.17のデータを全て使って 更新したい場合は リスト6.17のデータを全て使って 更新したい場合は

16.18のアップデートメソッドの引数がたった一つになっていてすごくすっきりしています 朱越ですよね ファサード どんなに内部が複雑でも外から見える窓口は常に一つでシンプルという状態を作り出せます 将来更新項目に住所が追加されてもアプリケーションサービスのメソッドのシグネチャー つまり引数の構成は一切変更する必要がないこれは非常に強力です 最後のデリート 大会処理はシンプルですね ユーザーを探して削除するだけ でもここにも面白い論点があると 削除対象のユーザーが見つからなかった場合 エラーにすべきかそれとももう存在しないんだから目的は達成されているとみなして正常終了にすべきか これはもう哲学的な問いに近いですね 哲学 どちらが正しいというわけではなくそのアプリケーションの要件次第です 指定されたIDのユーザーが確かに存在し それを削除したことを保証したいなら例外を投げるべきですし 最終的にそのユーザーが存在しない状態になればOKと考えるなら正常終了でいい こういう細部に設計者の意図が現れるんですよね なるほど 今の話もそうですけど CRUDを実装しているとついアプリケーションサービスに色々な判断を書きたくなってしまいます でも実はそれこそがこの設計における最大の罠なんだと資料は警告していますね まさにここが今回の話の確信かもしれません アプリケーションサービスにドメインのルールを記述してはならない この鉄則を破るとどうなるか 資料のリスト6.22と6.23が典型的な悪い例を示しています ユーザー名の重複チェックという紛れもないドメインのルールを 登録処理と更新処理の両方のアプリケーションサービスにそれぞれ直接書いてしまっている 一見手っ取り早く実装できてしまいそうですけどね その場で必要なチェックだからその場で書くというのは自然な発想にも思えます まあ短期的に見れば しかしこの設計がもだらす悲劇は 使用変更という未来の時点で必ずやってきます もし重複のルールがユーザー名からメールアドレスに変わったら 関連するすべてのアプリケーションサービス この場合は登録と更新の両方ですね そのコードを探し出して一時行く間違えずに修正しなければならない コードベースは大きくなれば修正漏れが必ず発生します 以前関わったプロジェクトでまさにこれがあったんですよ 登録処理は直したのに更新処理のチェックを直し忘れて大問題になりました

になったことがありました 知識が一箇所にないと 本当に怖い ですよ うわあ それは生々しい つまり 最初の実装は楽かもしれないけど 将来の使用変更という名の請求書 がとんでもなく高額になって帰って くるということですね 修正漏れ というバグの利子がついて まさにそのとおりです 正しい姿 はリスト6.27から6.29に示されている ように 重複チェックのロジック はドメインサービスであるユーザー サービスに一元化すること アプリケーション サービスはただその専門家を呼び 出すだけ ルールがたわっても 修正 はユーザーサービスの一箇所 だけで済みます 知識はその専門家 が持つべきなんです よくわかりました ルールは専門家 に任せると さてここまででも十分深い話でした が 資料はさらに一歩進んで より 良い設計のための業修道という 視点を提示していますね これは どういう概念なんでしょうか 業修道ですか ざっくり言うと クラスやモジュールの中身がどれ だけ密接に関連し合っているか を示す尺度です 関係ないものが ごちゃ混ぜになっていると低業 修 関連するものだけできれいに まとまっていると高業修と言います 高業修なクラスは責任が明確で 理解しやすく変更にも強いんです なるほど で この業修道というレンズで さっきのユーザーアプリケーション サービスを改めて見てみると 面白いことは分かります ユーザー リポジトリは登録 更新 削除 取得 といった全てのメソッドで使われます これはいい しかし重複チェック 用のユーザーサービスは登録と 更新でしか使われません あ 確かに 削除や取得のメソッドにとっては 全く無関係な存在なんです つまり 今のユーザーアプリケーション サービスクラスは少しだけ関係ない ものが混ざったやや低公衆性な 状態と言えます ほんの少しノイズが混じっている ような状態と そこで資料が提案するのが一つの 巨大なクラスではなくユースケース ごとにクラスを分割するという リファクタリングですね ユーザーレジスターサービス登録 専門とユーザーディリートサービス 大会専門というように その通りです リスト6.33と6.34が その例ですね こうして分割する とユーザーディリートサービス には不要だったユーザーサービス への依存が完全になくなります それぞれのクラスがたった一つの 責任に集中できる 非常に見通しがよくなります ユースケースごとにクラスを分ける ですか それはそれで今度はファイル 数が爆発的に増えてしまって 逆に全体像が

つかみにくくなるなんてことにはなりませんかね 良い指摘です 開発者が抱く当然の懸念ですよね だからこそパッケージという仕組みが生きてくるんです 物理的には userregisterservice.cs userdeleteservice.csとファイルは分かれていても application.usersといった名前空間やフォルダで 論理的にグルーピングするんです そうすれば全体としては ユーザーに関するアプリケーションサービス群としてまとまってみえ 個々の責務は明確に分離されているという理想的な状態を実現できます いやーすごく整理できました つまりアプリケーションサービスはあくまで指揮者であって 演奏家であるドメインオブジェクトに口を出しすぎてはいけないと 特にビジネスの根幹に関わるルールは 絶対に自分で書かずに 専門家つまりドメインサービスに任せる そしてお客さんであるUIとのやり取りでは 舞台裏の楽屋ドメインオブジェクトを見せるんじゃなくて DTOっていう綺麗なパンフレットを渡してあげる 最後に指揮者自身も欲張らずに 一つの局つまりユースケースごとに 専門の指揮者を立てるくらいがちょうど良いということですね 素晴らしいまさにその通りです そのまとめ方完璧ですね では最後にこの話をあなたの行動につなげるための思考を促すという一つ 今回の資料ではテストのしやすさなどを目的に アプリケーションサービスのインターフェースを用意する という話にも少し触れられていました ああありましたね リスト6.35や6.37で アイユーザーレジスタサービスのようなインターフェースを定義していました そうです私たちは今日 アプリケーションサービスが何に依存するかを見てきましたよね リポジトリやドメインサービスに依存していました ここで視点を180度変えてみましょう あなたのアプリケーションはアプリケーションサービスにどう依存していますか 逆の視点ですね UIのコードがユーザーレジスタサービスのような具体的なクラスを直接呼び出しているのか それともアイユーザーレジスタサービスという抽象的なインターフェースを介しているのか もし後者であればテストの際には本物の代わりに 偽物のサービスを簡単に差し込むことができます この依存の方向を逆転させることで 行動はより柔軟でテストしやすくなるんです あなたの行動の中でこの依存関係を逆転させて より良い構造に変えられる箇所もどこか一つ探してみていかがでし