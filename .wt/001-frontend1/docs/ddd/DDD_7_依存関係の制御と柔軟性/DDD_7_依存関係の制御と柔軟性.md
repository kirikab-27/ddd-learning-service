今回のテーマソフトウェアの柔軟性ですお預かりしたドメイン駆動設計に関する資料をもとに依存関係のコントロールという一見地味なんですけど 実はソフトウェアの寿命を左右するほど重要なテクニックについて深く掘り下げていきたいと思います はいよろしくお願いしますこれ本当に大事なテーマですよねそうなんですよまずちょっと想像してみて欲しいんですけど ジェンガーってありますよねあージェンガーはいはい注意深く組み立てた塔の真ん中あたりのブロックをこうそーっと抜こうとする時のあのヒヤッとする感じ わかります上のブロックが全部崩れてくるんじゃないかっていう怖いですよね まさにそれです複雑に絡み合ったソフトウェアの高度変更ってあの恐怖ともそっくりなんですよね 今回はですねこの開発者が日々感じる恐怖を取り除いてソフトウェアをいつでもこう自信を持って柔軟に変更できるようにするための設計思想その革新に迫っていきます いいですねでまず理解しておきたいのがプログラムでオブジェクト同士が依存し合うのってもうごく自然なことで避けようがないんですよね だから今回のゴールは依存をなくすことじゃないんです 重要なのはその依存の向きを我々開発者が完全にコントロールすることなんです 特に今回のミッションはビジネスの核になるロジックですね これをデータベースみたいな特定の技術的詳細から解放してあげることなんです 主導権を取り戻すみたいな感じですか まさにソフトウェアの設計方針の主導権を本来あるべきビジネスロジック側に取り戻す そのための具体的な道のりを一緒に探っていきましょうでは早速ですが資料にある ユーザーアプリケーションサービスというクラスの例から見ていきましょうか はい最初のコードだとこのクラスはユーザーリポジトリという具体的なクラスに直接依存している とありますね 正直これってまあごく普通に見えるんですが何がそんなに問題なんでしょう 一見するとごく自然なコードですよねでもここに大きな罠が進んでるんです 罠ですか はいこのユーザーリポジトリっていうのは実際にデータベースとやり取りをするクラスです つまりユーザー登録といったアプリケーションの

の重要なビジネスルールを担う ユーザーアプリケーションサービス が特定のデータベースっていう 技術的な詳細にがっちりと縛りつけ られてしまっている状態なんです これがすべての問題の始まりです なるほど縛りつけられているそれが 具体的にどういう痛みにつながるん でしょう 痛みは主に二つありますまずとに かくテストがしにくい テスト ユーザーアプリケーションのロジック が正しく動くかほんの少し確認 したいだけなのにそのためには 本物のデータベースを起動して テーブルスキーマを整えてテスト 用のデータを投入してみたいな わあ大掛かりな準備が必要になる わけですね そうなんですほんの数強のコード を試すために数分場合によって は数十分かかるこれは開発のリズム を著しく損ないます ああそれは経験ありますねなんか ちょっと試したいが全然ちょっと じゃなくなる感じ まさにそしてもう一つのより深刻 な問題が将来の技術変更への体制 です例えば数年後このサービス のデータは従来のデータベース よりノーsqlの方が相性がいいね みたいな話になったとします その時にデータベースを差し替え ようと思ってもビジネスロジック の塊であるユーザーアプリケーション サービスがべったり依存している せいでそっちのコードまで大幅 に書き換える必要が出てくる これはまるで車のエンジンをシャーシ に直接溶接してしまっているような ものですね ああなるほど性能のいい新しい エンジンが出ても簡単には乗せ 換えられないビジネスの成長に合わせて 技術も進化させたいのに過去の設計 が足枷になってしまうんです ここからがこの話の面白いところ ですよね ええ 解決策としてユーザーアプリケーション サービスが具体的なユーザーリポジトリ ではなくiユーザーリポジトリという インターフェースつまり抽象型 に依存すると そうなんです これって間に契約書を一枚挟む ようなそういうイメージですか おっしゃるとおりですインターフェース はまさにこういう機能を提供します と約束する契約書なんですよ ほう ユーザーアプリケーションサービス はもう具体的なデータベースの 実装を見る必要はなくなります ただその契約書だけを見てこの

契約通りに動いてくれるなら相手 は誰でもいいですよっていうスタンス になるんです なるほど テストの時にはメモリ上で高速 に動く偽物のクラスでもいいです し本番環境では本物のデータベース につなぐクラスでもいい契約書 さえ守っていれば相手を自由に 取り替えられるようになります つまり依存の矢印が具体的な実装 から抽象的な契約に向きを変える わけですね そしてこれが資料で紹介されている 依存関係逆転の原則ディペンデンシー インバージョンプリンシプルの 核心なんです 依存関係逆転の原則 はいこの原則には2つのシンプル なルールがあります a 上位レベルのモジュールは下位 レベルのモジュールに依存しては ならない両方とも抽象に依存すべき である ふむふむ そしてb 抽象は実装の詳細に依存 してはならない実装の詳細が抽象 に依存すべきであると ちょっと待ってください上位レベル と下位レベルというのはどういう 意味合いで使われているんでしょうか あはいこれは機械からの距離感 で考えると分かりやすいかもしれません 機械からの距離感 ユーザーアプリケーションサービス のようなビジネスロジックは人間 が考える方針とかルールに近い 抽象度の高いものですよねこれが 上位レベル なるほど 一方でデータベースを直接操作 するユーザーレポジトリーのような クラスはハードウェアに近い具体 的な詳細を扱うこれが下位レベル です原則に反した最初の状態では 上位レベルの方針が下位レベル の詳細に直接依存していました でもインターフェースを導入する ことで上位レベルのユーザーアプリケーション サービスも下位レベルのユーザーレポジトリー も両方ともiユーザーレポジトリー という抽象に依存する関係に変わ るんです あー両方ともが抽象に向くんですね そうです依存の向きが逆転して 方針の主導権を本来あるべき上位 レベルのモジュールが取り戻す ことになるのです なるほど依存の向きを逆転させる という思想はよくわかりました でも優はやすしでこれを高度で 実現するとなると具体的なテクニック が必要になりますよね ええ 例えばテストの時だけダミーに差し 替えるなんて一体どうやるんですか 良い質問ですね

そこがまさに実践のポイントです 資料にもありますが まず一番やってはいけない例というのがあって はい ユーザーアプリケーションサービスのクラスの中で New In-Memory User Repositoryのように 直接インスタンスを生成してしまう方法 コードの中に直接書いちゃう そうです これだとテスト用に書き換えたコードを 本番リリース前にまたNew Real User Repositoryみたいに書き直さないといけない これではせっかくインターフェースを導入した意味が半減してしまいます 修正漏れとかヒューマンエラーの温床になりそうですよね その通りです そこで登場するのが この依存関係をクラスの外部から管理するためのデザインパターンです 資料では2つ紹介されていますね まず一つ目がサービスロケーターパターン サービスロケーター なんだか便利そうな響きですね ええ その名の通りサービスを探してくれる場所というイメージで はい プログラムのどこか一箇所にサービスロケーターという 中央管理局みたいなものを用意しておいて 起動時にiUserRepositoryが必要と言われたら inMemoryUserRepositoryを渡してくださいといったルールを登録しておくんです なるほど そしてUserApplicationServiceのようなクラスは 必要な時に自分でサービスロケーターに問い合わせて iUserRepositoryをくださいとお願いしてインスタンスをもらう 設定を一箇所に集約できるので 一見すると非常にスマートに見えます 待ってください それってすごく便利そうに聞こえますけどね 設定ファイル一つでアプリケーション全体の動きを切り替えられるなんて むしろ良い設計なんじゃないですか そう思いますよね ええ でも資料ではアンチパターンとまで言われていますが 何がそんなに致命的なんでしょう そこなんですよ 実は以前このサービスロケーターを対応した巨大なプロジェクトを 引き継いだことがあるんですが もう大変で ほう 依存関係が全く見えない 何か修正しようにも どのクラスが何を要求しているのかさっぱりわからなくて どこを直せばいいのかコードを追いかけるだけで 一日が終わるなんてこともザラでした うわあ あの経験で依存関係の可視性がいかに重要か身をもって知りましたね なるほど 実体験から来る言葉には重みがありますね サービスロケーターにはその経験からも言える大きく2つの

致命的な欠点があります 1つはまさに今言った依存関係が 隠蔽されてしまうこと 隠蔽されてしまう はい ユーザーアプリケーション サービスのクラス定義 つまり コンストラクターやメソッドの シグネチャーを見ただけでは その クラスが内部でIユーザーレポジトリ をこっそり使っていることが全く わからないんです ああ 一見すると何も依存していない 自己完結したクラスに見えてしまう わけですね そうなんです そして もし開発者がサービスロケーター への登録をうっかり忘れたまま プログラムを実行するとどうなる か ユーザーアプリケーションサービス が使われるその瞬間まで問題は 発覚せず 実行時にいきなりエラー で落ちるんです 実行してみない とわからないというのは非常に 立ちの悪い問題です なるほど そしてもう一つの欠点 は何ですか テストが壊れやすくなることです これがさらに深刻で 例えば ユーザーアプリケーション サービスに新しい機能を追加する ためにiFooレポジトリという新たな 依存関係を追加したとします サービスロケーターを使っている と コンストラクターは引数なし のままなので この変更を加えて も 既存のテストコードはコンパイル エラーにはなりません そしてテストを実行して初めて iFooレポジトリが登録されていない という実行時エラーで失敗する ことに気づくと その通りです 開発者にとってテスト は品質を守るための胃もつなですけ ど 同時に維持するのは面倒なもの でもありますよね ええ こういう実行するまで気づけない タイプの問題が頻発すると だんだんテストを修正するのが 億劫になって やがてテストは放置され 境外化 していく そうなるとソフトウィアの品質 は坂道を転がるように落ちていきます なるほど 便利さの裏に大きな落とし 穴があるわけですね では これらの問題を解決するより 優れたパターンとは何なのでしょう それが資料の結論でもあるIOCコンテナ を利用したディペンデンシーパターン です ディペンデンシー ええ まずディペンデンシーインジェクション 日本語で依存性の注入というのは クラスが必要とするオブジェクト を内部でこっそり調達するんじゃ なくて 外部からコンストラクター の引数などを通じて堂々と注入 してもらうという非常にシンプル な考え方です ああ なるほど つまり依存関係が コードの使用の一部としてコンストラクター に明記されるわけですね

まさに ドキュメントを読まなくても シグネチャを見れば何が必要なのか 一発で分かると その通りです 依存関係が認定されず クラスのAPIとして明確になる そして IoCコンテナというのは この注入作業を賢く自動化してくれるツールなんです サービスロケーターと同じように あらかじめコンテナに Iユーザーリポジトリにはインメモリーユーザーリポジトリを といったルールを登録しておきます そして我々が ユーザーアプリケーションサービスの インスタンスをくださいとコンテナに要求するだけで コンテナが自動的に ユーザーアプリケーションサービスの コンストラクターを解析して なるほど Iユーザーリポジトリが必要なんだな と理解し ルールに従ってインメモリーユーザーリポジトリを生成し それを引き継ぎ渡して ユーザーアプリケーションサービスの インスタンスを組み立ててくれるのです 依存関係のツリーがどれだけ複雑になっても 全て面倒を見てくれます すごいですね サービスロケーターのように 設定を一元管理できる便利さは そのままに 依存関係が隠蔽されるという致命的な欠点を 見事に克服している そして私がこのパターンの最も素晴らしいと 考えている点が テストに与えるポジティブな影響です ほう 先ほどと同じように ユーザーアプリケーションサービスの コンストラクターに iFUリポジトリという 新しい引数を追加したとしましょう その瞬間 何が起きると思いますか? あっ ユーザーアプリケーションサービスを 入手している全てのテストコードが 引数が足りないという理由で 一斉にコンパイルエラーになる それです このコンパイラーエラーは 単なるエラーじゃないんです これは未来の自分 あるいはチームの同僚を 深夜のデバッグ地獄から救うための 安全装置が作動した音なんですよ なるほど テストを実行するまでもなく コードを書いているその場で コンパイラーが おい 君がやった変更の影響が テストにも及んでいるぞ ちゃんと直せと教えてくれる この設計による強制力こそが テストを常に健全な状態に保ち ソフトウェアの品質を長期的に守る上で 絶大な力となるのです これは強力ですね ただ これだけ素晴らしいと 逆に何かデメリットはないのか気になります 例えば ごく小さいツールを作るときにも こういう大掛かりな仕組みは必要なのでしょうか? 非常に良い視点ですね もちろん どんな銀のダメージも

何がも存在しません DIコンテナにもトレードオフはあります はい おっしゃる通り 数個のファイルで完結するような 小さなスクリプトとかツールに導入するのは 明らかに過剰装備です ふむふむ あとはコントナーは機能時に依存関係を解決する処理が入るので ほんのわずかですが アプリケーションの起動が遅くなる可能性はあります そして初めて使う人にとっては 設定方法などを学ぶ学習コストもかかります なのでプロジェクトの規模やチームのスキルセットに合わせて 適切なツールを選択する視点は常に重要ですね よくわかりました ではまとめましょう 今回はまるでジェンガのように脆く 変更が怖いソフトウェアの構造という問題提起から始まりました ええ その柔軟性を取り戻すための依存関係のコントロールという旅をしてきましたね はい 具体的なクラスにべったり依存するんじゃなくて インターフェースという抽象的な契約に依存すること うんうん そしてその依存関係をディペンデンシーインジェクションと IOCコンテナという仕組みを使って外部から注入することで 変更に強くテストしやすい健全でソフトなソフトウェアを構築できる ということが非常によく理解できました ええ 資料の最後にもありましたけど ソフトウェアがソフトと呼ばれるゆえんは 本来変化に柔軟に対応できるはずだからです そうですよね 依存関係は避けられませんが その向きと管理方法は我々開発者が完全にコントロールできる領域です ビジネスの核となるドメインロジックをデータベースのような技術的な詳細から守り 常にシステムの主役であり続けさせること これが変化の激しい時代において価値あるソフトウェアを作り続けるための鍵となります 最後にこの話を聞いてくださっているあなたに考えてみてほしいという一つ 今回は上位レベルと下位レベルというモジュールの話でした この依存関係逆転の考え方を コードだけでなくあなたのチームの構造や あなた自身の学習方法に応用するとどんな景色が見えるでしょうか あなたの根本的な戦略目標が 今日流行っている特定のツールやフレームワークに依存してしまってはいないでしょうか それともあなたのツールの選択が 決して変わることがないはずのあなたの目標に依存しているでしょうか