こんにちは ザ・ディープダイブへようこそ あなたが共有してくれた ドメイン駆動設計に関する資料 今回もすごく面白そうですね 一緒に深く掘り下げていきましょう これまではリポジトリとかサービスとか 一つ一つの部品について見てきましたけど 今回のミッションはそれらをどうやって組み立てて 僕たちが普段使っているような ソフトウェアっていう形にするかですよね そうですね 家じょくりで言えば柱とか壁とか そういうパーツの作り方を学んで いよいよ家全体を建てる工程に入るっていう そんなイメージですね なるほど 分かりやすいです それで資料を読んで最初におっと思ったのが アプリケーションとソフトウェアを 区別しているところなんです ああはいはい ドメインの問題を解決する心臓部がアプリケーションで それにユーザーインターフェイスみたいな 側を着せたものがソフトウェア この考え方が今回の話の すべての土台になっているように感じました まさに そこの区別がもうめちゃくちゃ重要なんです UIって言っても黒い画面に文字を打ち込む CLIもあれば 僕らが普段スマホで触っているような GUIもあるじゃないですか ええ ありますね でもユーザーを登録するみたいな ビジネスの核になる処理って UIがどっちだろうと関係ないはずですよね 確かに そこをちゃんと切り離せるのが ドメイン駆動設計のすごくいいところだと思うんです 心臓部さえしっかり作っておけば 体 つまりUIはキセガエ人形みたいに取り替えられると はい そういうことです もし本当にそんなことができたら 開発の仕方が根本から変わりそうですね 今日はその具体的な方法を見ていけるということで 楽しみです そして面白いのが これから見ていくCLI ウェブアプリ それからユニットテストっていう 全然違う3つの顔にですね 同じアプリケーションの心臓部を ポンとはめ込んでいくんですよ その過程でこの設計の進化が見えてくるはずです まずは一番シンプルなCLI コマンドラインインターフェースからですね 正直開発者じゃない人からすると なんで今さらこの黒い画面って思うかもしれないですけど 資料によるとここから始めるのには やっぱり理由があるんですよね そうなんです 自由は大きく2つあって 1つは余計な装飾がないから

アプリケーションの組み立てっていう 本質的な部分に集中できること ああ なるほど で もう一つは プログラムで自動的に動かしやすいので 後々テストをするときにも役立つからなんです いきなり華やかなウェブアプリから入ると どうしても見た目の問題に気を取られがちなので まずは骨格からというわけです なるほど それで その骨格を組み立てるためのキーテクノロジーとして IOCコンテナというのが出てきます サービスコレクションとか これ正直なところ ちょっととっつきにくい概念だなって思う人も多いと思うんですが 一言で言うと これ何をしてくれるやつなんでしょう いい質問ですね これは何というか依存関係の管理人みたいなものですね 依存関係の管理人 ええ 例えば ユーザーアプリケーションサービスは 仕事をするのにIユーザーリポジトリが必要ですよね はい こういうAはBが必要という関係を依存関係って言うんですけど 普通にプログラムを書くと ユーザーアプリケーションサービスの中で ニュー ユーザーリポジトリをしゃ みたいに自分で部品を作っちゃうんです ああ やりますね 普通に でも それだと部品の交換が大変になる IOCコンテナはそのニューを全部一箇所で引き受けてくれるんです Iユーザーリポジトリが必要って言われたら これを渡してねっていうのを最初に全部登録しておく そうすれば各クラスは自分が必要なものは誰かがくれると信じて 自分の仕事に集中できるんです へえ 面白い その登録の仕方で リスト8.1にAdd SingletonとAdd Transientっていう2つが出てきて 使い分けられてますよね ああ はい リポジトリはAdd Singletonなのに サービスはAdd Transient どっちもプログラムの中で1つあれば良さそうな気もするんですが これ何か深い理由があるんですか そこすごく大事なポイントです まずAdd Singletonはプログラム中で絶対に1つだけっていう設定ですね 今回使っているIn-Memory User Repositoryは 作ったユーザーのデータをメモリー上の1つのリストで管理してるんです もしこれがシングルトンじゃなくて 要求される度に新しいリポジトリが作られたらどうなりますか あ ユーザーを登録したそばからそのデータが消えちゃうってことか なるほど だからリポジトリは1つじゃないとバメなんですね その通りです じゃあ なんでサービスはAdd Transient

つまり毎回新品を作る設定なのか これはインスタンスの寿命をできるだけ短くしてシンプルに保つためです 使い捨てのコップみたいなものですね 使い捨てのコップ? ええ、毎回新しいものを使うから衛生的 というか他の処理の変な影響を受けずに いつもクリーンな状態で仕事を始められる 特にこだわりがなければ 毎回新品を作る方が安全で間違いが少ないという設計思想なんです なるほどな ここで資料のコラムに シングルトンパターンの話が出てきて ハッとさせらげました スタティックにしちゃうのと IOCコンテナでシングルトンにするのは 似ているようで全然違うんですね そうなんですよ スタティックはもうそのクラス その実装にガチガチに固定されちゃう 後からテスト用に差し替えるなんてことができなくなるんです ああ でもIOCコンテナのシングルトンは あくまでiUserRepositoryという 役割を担うインスタンスは一つという契約なんです だからその役割を果たすのが inMemoryUserRepositoryだろうと 後で出てくる本番用のデータベースだろうと 自由に差し替えられる この柔軟性が決定的に違います うわあ それ多くの人が混同してそうなポイントですね スタティックはこの実装そのものに縛られるけど IOCコンテナは この役割に対してインスタンスを管理する 全然意味が違うんだ ええ そしてこのIOCコンテナの真の力が発揮されるのが リスト8.3なんです たった一行AdSingleton iUserRepository inMemoryUserRepositoryを書き換えるだけで メインの処理には一切触らずに メモリー上のデータストアから 本番のデータベースに切り替えられる アプリケーションの心臓部は 自分が話している相手が誰なのかを知らないんです ただiUserRepositoryという役割の人に話しかけているだけ これこそが狙撃号な設計の力ですね CLIはシンプルで分かりやすかったですけど やっぱり多くの人がイメージするのは ウェブアプリですよね 同じ考え方がASP.NET Core MVCみたいな もっと複雑なフレームワークの中で どう生きてくるのかそこが気になります ええそこですよね ウェブアプリになるとCLIみたいに メイン関数から順番にというわけにはいかないですから ですよね ユーザーがいつどのボタンを押すか分からないですし この資料の図8.1を見ると ユーザーがリクエストを送ってから 僕らが作ったコントローラーが動くまでに

フレームワークと IoC コンテナが 裏でいろいろやってるみたいですけど この辺りの流れってどうなってるんですか? 基本的な考え方は CLI と一緒なんです まず ウェブアプリが起動するときに スタートアップという場所で CLI のときと同じように ユーザーリポジトリが欲しがられたら これを渡して みたいに IoC コンテナに 依存環境を全部登録しておくんです はいはい まず登録する そして ユーザーからリクエストが来ると フレームワークが この URL なら このコントローラーを動かそうと判断して そのコントローラーを作ろうとします そのとき コントローラーが 私はユーザーアプリケーションサービスが 必要ですと宣言していれば IoC コンテナがはいどうぞって 登録済みのサービスを自動的に渡してくれる こういう仕組みです なるほど だからプログラマーは コントローラーの中でニューを書かなくていいんですね でも ここで実践的な問題が 開発中はメモリーで動かして 本番環境ではデータベースを使いたいってなったときに 毎回このスタートアップのコードを書き換えるのは ちょっとめんどくさいだし間違いそうですよね まさに そこで資料が提示するのが 設定を環境ごとに分離するというアイデアです 開発用の設定スクリプトと 本番用の設定スクリプトを 別々なファイルとして用意しておく ああ ファイルを分けるんですね そして appsettings.json という いわばアプリの設定指示書みたいなファイルに 今回は開発用の設定を使ってくださいと 一言書いておくだけなんです ああ なるほど コードは一切変えずに その指示書を書き換えるだけで 本番と開発の切り替えができると そういうことです これでうっかり開発用の設定のまま 本番にリリースしちゃったみたいな事故も防げます いや 理屈はすごくよく分かります でも正直なところ 小さなプロジェクトだと とりあえず動けばいいやって 設定ファイル一つで全部やっちゃいませんか? このやり方ってどのくらいの規模のプロジェクトから 本当に意味を持ってくるんでしょう? おっしゃる通り 本当に一人で一日で終わるようなプロトタイプなら そこまでする必要はないかもしれません でもチームが二人以上になったり 一度リレースして終わりじゃなくて その後も機能追加やメンテナンスが続くなら このひと手間が後々の あの時ちゃんと分けておけばよかった っていう後悔を防いでくれるんです あー 未来の自分への投資みたいなものですね

未来の自分への投資、良い言葉ですね さて、設定が済んだところで いよいよユーザーの操作を受け付けるコントローラーです 資料のコラムにあるゲーム機のコントローラーの例えが ものすごくわかりやすかったです あれは秀逸な例えですよね プレイヤーの指の動き、つまりHTTPリクエストを ゲーム機本体、アプリケーションが理解できる電気信号 コマンドオブジェクトに変換するのが仕事 それ以上のことはしないと まさにリスト8.11のコードを見ると コントローラーの中にはビジネスロジックが全くない ただリクエストのデータを ユーザーレジスターコマンドみたいな箱に詰めて ユーザーアプリケーションサービスに お願いしますって渡しているだけですね ええ、だからもしコントローラーに イフ文がたくさんあったり複雑な計算をしていたりしたら それはやりすぎのサインなんです ドメインの知識があるべき場所、つまりドメインモデル とかアプリケーションサービスから 出してきている証拠ですね ということはコントローラーがシンプルで退屈なコードに見えたら それはむしろ設計がうまくいっている証拠ということですね そうなんです 以前私が関わったプロジェクトで まさにコントローラーにロジックが あふれ出てしまっていたことがありました へえ 最初は小さな入力チェックだったのが どんどんビジネスルールが追加されて 気づいけば巨大なメソッドになっていて 後からそれをアプリケーションサービスに切り出すのに 本当に苦労しました だからコントローラーは薄く保つというのは もう身に染みてますね うわあリアルな話 UIからロジックを分離すると コントローラーがスリムになる そしてもう一つの大きなご利益が このユニットテストなんですよね ここで今までこだわってきた インメモリーでの実装が ついに本領を発揮すると はい いよいよ毎日登場です ユニットテストの鉄則は とにかく早く独立して動くこと テストのたびに いちいち本物のデータベースに つなぎに行ったりしたら 遅いし 他のテストの結果に影響されたりして 非常に不安定になります そこで インメモリーユーザーリポジトリの出番だと その通りです これを使えば データベースなんてなくても アプリケーションのロジックが正しく動くかを 一瞬で検証できるんです テストって書くのが大変なイメージがあるんですけど ここまでちゃんと設計が分離されていると やっぱり書きやすくなるものなんですか 劇的に書きやすくなります なぜなら

テストしたい対象 今回はユーザーアプリケーションサービスですけど それとそれが依存しているもの iUserリポジトリを完全に切り離せるからです ああ なるほど リスト8.13の正常系テストを見てください ユーザー名が3文字の場合と20文字の場合というビジネスルールの境界値で ちゃんと登録できるかをテストしています テストの中でインメモリーユーザーリポジトリを直接作ってサービスに渡しているので 外部環境に一切依存していません ここでまた面白いテクニックが紹介されてますね テストのためにリポジトリの内部データストアプロパティをわざわざ公開するっていう これカプセル化の原則を破っているみたいでちょっとドキッとしませんか? いいところに気づきましたね 確かにそう見えるかもしれません でも大事なのはアプリケーション本体は iUserリポジトリという革を通してしかリポジトリに触れないので このストアプロパティの存在をそもそも知らないんです ああ そうか この中身を直接覗くのは全てを知っているテストコードだけ いわばお医者さんが昇進器を当てるようなもので 普段は隠されている心臓の音を聞くための特別な許可証みたいなものですね なるほど テストという特別な目的のために 特別なアクセス権を与えていると考えればいいんですね 安全性が担保されているならこれはすごく便利なテクニックだ ええ そして異常系のテストも重要です リスト8.16ではユーザー名が短すぎたり長すぎたりした場合に ちゃんと想定通りのエラーが起きることを確認しています リスト8.17では同じユーザー名で二重登録しようとしたときに ちゃんと重複エラーになるかをテストしている こういうちゃんと失敗することを確認するテストがあるからこそ 開発者は安心して新しい機能を追加したり コードを修正したりできるんです そしてこういうテストコードってただバグを見つけるだけじゃないんですよね そうなんです これが生きたドキュメントになる 使用書が古くなって誰も信じなくなったとしても このテストコードは嘘をつきませんから これが動いている限りシステムの振る舞いはこうなっている という絶対的な証拠になるんです ドキュメントがないプロジェクトではこれが最後の取り出になることさえあります いやー こうしてみるときれいな設計が いかに未来の自分たちを助けてくれるかがよくわかりますね UIを交換可能にしアプリケーションとしても

アプリケーション単体でテストできるようにする これが品質を守ることにつながると それで最後に資料はすごくしさに富んだ というかちょっと背筋が寒くなるような 怪談話で締めくくられているんです 怪談話ですかぜひ聞きたいですね これは秘書の方が実際に経験した話だそうです 15年ほど前のレガシーシステムで asp.net webformsという古い技術で作られていた 当然もう書ける技術者もいなくなって より一般的なMVCに乗り換える必要に迫られたそうなんです でもいざコードを開いてみたらもう地獄だったと すべてのビジネスロジックが UIのブタンクリックのイベントハンドラーなんかに 直接書かれていた しかも似たようなロジックが いろんな画面にコピー&ペーストされていて それぞれが微妙に違う進化を遂げていた 当然ユニットテストもなければ まともなドキュメントもない 結局その筆者の方にできたのは すべてのコードを読んで 使用を推測し ゼロから全部作り直すことだけだった というまさに恐怖体験です それはまさに悪夢ですね 開発者なら誰でも一度は 似たようなコードの森で迷子になった 経験があるんじゃないでしょうか UIの交換なんて滅多にないよって 僕も昔は軽く考えていました でもこの話が教えてくれるのは 技術の陳腐化っていう 僕たちの意思とは関係なくやってくる 避けられない変化が必ずあるってことなんです 今日見てきた設計原則は その時に備えるための すごく現実的なサバイバル術だったわけですね 未来の自分たちを救うためのサバイバル術 そこで最後にあなたに一つ問いかけてみたいんです この軽談話は技術の移り変わりで 変えるはずのなかったUIを 変えざるを得なくなった話でした でも本当に怖いのは UIだけじゃないかもしれません あなたが今作っているシステムで ここのビジネスルールは絶対に変わらない と信じている一番の心臓部は何ですか もし5年後10年後 全く新しいビジネスモデルが登場して その絶対を根底から崩さなければならなくなったとしたら その時あなたのソフトウェアは その変化という大手術に耐えられますか