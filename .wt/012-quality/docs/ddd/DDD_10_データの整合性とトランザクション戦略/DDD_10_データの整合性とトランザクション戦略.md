まず、すごく身近な例から入ってみましょうか。 あなたがネット通販で何か注文を確定したとしますよね。 はい。 その注文データって、誰に送るかのヘッダー情報と 何を注文したかのボディ情報、これがありじゃないですか。 ええ、ありますね。 もし、何かのプログラムのエラーでヘッダーだけが保存されて ボディが消えちゃったら、あるいはその客だったら これ、注文は成立しないですよね。 しませんね。 まさにそれが、データの整合性が崩れた状態ということです。 ヘッダーとボディは常にセットじゃないと意味がない。 ええ。で、今回はですね、お預かりしたドメイン駆動設計に関する資料の中から まさにそのデータの整合性というソフトウェア開発ですごく重要で 避けては通れないテーマを掘り下げていこうと思います。 面白いテーマですね。 当たり前を守るのが実は一番難しいっていう。 そうなんです。しかも、資料によるとこれから見るサンプルコードには 致命的な不具合が存在していると。 ええ。一見すると本当に何の問題もなさそうなコードに隠された、まあ落とし穴ですね。 これを解き明かしていくのは結構面白い旅になりますよ。 楽しみです。 じゃあ、その不具合の正体から始まって、それをどう解決していくのか いろいろな戦略のメリット・デメリットまで一緒に探っていきましょう。 これって多分、すべての開発者が直面する可能性のある すごく実践的な問題への探求ですよね。 おっしゃる通りです。 では早速ですが、問題のコードを見てみましょうか。 資料にあるユーザー登録処理のコードです。 ルールはすごく単純で、ユーザー名は重複しちゃいけないと。 はい。 で、コードを見ると、ちゃんと保存する前に ユーザーサービス.エグジストっていうので 重複チェックを行っているんですよね。 これパッと見、どこに問題があるのかちょっと分かりにくいですね。 そうなんですよ。 コードを上から順に読む限りは、ロジックに穴はないように見えるんです。 チェックして、存在すればエラー、なければ保存。 教科書通りというか。 ええ。 でも、本当の敵はコードの中じゃなくて、 なんていうんですかね、時間っていう概念の中にいるんですよ。 時間ですか? もし、全く同じタイミングで、 2人のユーザーが全く同じNARSEっていう名前で登録しようとしたら、 どうなると思いますか? ああ、なるほど。 全く同じタイミングですか? 同時に、トンと。 その通りです。 いわゆる競合状態ってやつですね。 ちょっと具体的なシナリオで見ていきましょうか。 お願いします。 まず、ユーザーAの処理が重複チェックのエグジストメソッドを通過します。 データベースにはまだNARSEはいないので、 OK、登録できるなと判断されるわけです。 はい、それで次の行のセーブメソッドに進むと。 ここからが肝心で、 Aのデータがデータベースに保存されるその直前のほんのわずかな隙間、 コンマ何秒とかの間に、ユーザーBの処理も重複チェックを行うんです。 ああ。 Aのデータはまだ書き込まれてないんですよね。 なので、BのチェックもNARSEは存在しない、OKって通過しちゃうんですよ。 うわあ、なるほど。 結果的に同じNARSEさんが太りできちゃうと。 そういうことです。 これが資料で言っていた致命的な不具合の正体なんですね。 ウェブアプリケーションみたいに同時にたくさんのリクエストを捌くシステムだと、 これはもう日常的に起こり得る脅威じゃないですか。 まさにその通りです。 で、一度こういうデータの不整合が起きると、原因の調査がものすごく大変で。 ああ、想像つきます。 昔、これと全く同じ競合状態で発生したデータ不整合の調査に、私3日間とかしたことがありますよ。 ログを見ても単体でテストしても何にも問題ない。本当に悪夢でした。 3日間。それは厳しいですね。 だとしたら、最初の防御策としてアプリケーションのコードだけじゃなくて、 データベース自身にこのカラムは絶対に重複させないでってお願いする手が考えられますよね。 ええ。 資料にあるユニークキー制約のあしょれですね。 ええ。それが第一の、そして非常に強力な防衛ラインになります。 データベースの層で重複を検知してエラーを返してくれるんで、データの矛盾はこれで確実に防げます。 はい。 すると、多くの開発者はこう考えちゃうんですよ。 あれ?データベースが守ってくれるなら、アプリケーションのExistチェック、これもういらないんじゃないって。 ああ、でもそれすごくわかります。実務的にはコードはシンプルな方が良いっていう考え方もありますし、 データベースが保証してくれるなら、アプリ側のコードはDRYの原則に従って消すべきだって主張する人も多そうですよね。 多いですね。 なぜそれでもコードに残すべきなんでしょう。 それは素晴らしい問いですね。まさにそこがこの問題の奥深いところで、コードを消すことには大きな問題が二つあるんです。 二つも? 一つ目は表現力の喪失。コードからユーザー名は重複してはならないっていうアプリケーションにとってすごく大事なビジネスルールが消えてしまう。 なるほど。 コードを読んだだけじゃ、その制約の存在に誰も気づけなくなるわけです。 確かに、ドキュメントを読むか、データベースの定義を直接見に行かない限りルールが隠れちゃうわけですね。 そして二つ目はもっと深刻な技術への依存です。ビジネスルールが特定のデータベース技術、つまりリレーショナルデータベースのユニークキー制約っていう実装の詳細に完全にくっついちゃうんです。 ああ。 もし将来データベースをMOSQLに変えることになったらどうでしょう。この隠れたルールに気づいて、新しい環境でちゃんと再現できるでしょうか。 ドメインのルールが本来いるべき場所から漏れ出してしまっている状態なんです。 よくわかりました。つまり、ユニークキー制約はルールそのものとして頼るんじゃなくて、あくまでセーフティーネットとして使うべきだと。 その通りです。 アクリキューションの高度でビジネスルールをはっきり表現しつつ、万が一の競合によるすり抜けをデータベースが最後の防衛ラインとして防いでくれる、この二段構えが理想ということですね。 まさにおっしゃる通りです。さて、この二段構えをもっと堅牢にするための仕組みがあるんです。 おお。 それがトランザクションです。 出ましたね、トランザクション。一連の処理をすべて成功させるか、さもなければ全部なかったことにするっていう仕組み。通販サイトのポイント利用と在庫の引き落としが必ずセットで行われる、あれと同じ考え方ですよね。 ええ。トランザクションを使えば、先ほどのユーザー登録の問題は解決します。 重複チェックとデータ保存という一連の処理が他の処理から隔離されるので、一方の処理が終わるまでもう一方は待たされるか、エラーになる。これで競合状態そのものが起こらなくなるんです。 なるほど。トランザクションで囲めば競合はもう起きないと、これで解決と考えてしまいそうですけど、資料を読み進めるとまた何か落とし穴があるようですね。 そうなんです。整合性は手に入るんですが、素朴な実装をすると別のものを失ってしまうんですよ。 別のもの。 例えば、ユーザーアプリケーションサービスみたいなアプリケーションのロジックを担うクラスが、SQLコネクションとか、そういうデータベース接続のための具体的なオブジェクトを直接扱うことになってしまうんです。 ああ、トランザクションを開始したりコミットしたりするためにどうしても必要になっちゃうから。 ええ。 また同じ問題の繰り返しですね。ビジネスルールがまたしても特定の技術、今回はリレーショナルデータベースの接続オブジェクトに汚染されてしまうと。 そうなんです。 これじゃあテストのためにメモリ上で動かしたいみたいな場合にすごく困りますよね。一歩進んで二歩下がるみたいな感じがします。 まさに、トランザクションの恩恵は受けたい、でも特定の技術には縛られたくない。このジレンマを解決するために先人たちはいくつかのすごく賢い設計パターンを生み出してきたんです。 ぜひ教えてください。その高度なパターンというのは。 はい。まずCシャープの世界でよく使われるのがトランザクションスコープです。 トランザクションスコープ。 これはここからここまでの処理の範囲は整合性が必要ですよって宣言するようなものですね。 ユージング区でスコープを作るだけでフレームワークが裏側で自動的にトランザクションを開始してくれるんです。 なるほど。ビジネスロジックを書く人は整合性が必要って意思表示をするだけでSQLコネクションみたいな具体的な道具に触らなくて済むわけですね。 その通りです。具体的な実現方法はインフラ層に任せられる。 うまい仕組みですね。 次にJavaなんかで主流なのがAOP、アスペクト思考プログラミングを利用したパターンです。 AOP。 AOPっていうのは言うならば処理のキセカエみたいなものでして。 キセカエですか。面白い表現ですね。 本来のメソッドのコードには一切手を加えずにトランザクション管理っていう機能の副を外から着せてあげるイメージです。 具体的にはメソッドにアットトランザクショナルみたいなアノテーションという印をつけるだけ。 印をつけるだけで。 それだけでフレームワークがメソッド全体を丸ごとトランザクション化してくれるんです。 資料の筆者もコードの意図がこれはトランザクション処理ですって一目で分かるのでこのパターンを高く評価してますね。 そして3つ目がユニットオブワーク。これは名前からしてちょっと複雑そうです。 これは考え方が少し違いますね。ショッピングカートに似てるんですよ。 ショッピングカート。 はい。商品を一つカートに入れるたびにレジに行くんじゃなくて買いたいものを全部カートに入れて最後に一度だけレジで生産しますよね。 そうですね。 ユニットオブワークも同じでデータベースへの変更つまり作成とか更新とか削除をその都度実行するんじゃなくて一旦ユニットオブワークっていうカートにためておくんです。 ふむふむ。 ビジネス上の一連の処理が終わった最後にコミットを呼び出すとカートにたまってた変更がまとめてデータベースに生産つまり適用されると。 Cシャープのエンティティーフレームワークなんかはまさにこのパターンの優れた実装例ですね。 なるほど。ショッピングカートですか。すごくわかりやすいです。 いやーこれだけ選択肢が出てくると逆に迷ってしまいますね。 もしあなたが今この問題を解決するコードを書くとしたらどれを選びますか。 そうですね。資料の筆者も推奨していますが私もトランザクションスコープとかAOPみたいな宣言的なアプローチを好みますね。 宣言的。 ええ。理由はやはりビジネスロジックとインフラ技術をきれいに分離できるからです。 Cシャープならトランザクションスコープ、JavaならAOPが最初の選択肢になるでしょうね。 ユネットオブワークはより強力ですけど少し複雑さが増すので状況に応じて選択するという感じです。 そしてどのパターンを使うにしても最後に一つすごく重要な警告が資料にありましたね。ロックについてです。 これは絶対に忘れてはいけない注意点です。トランザクションは整合性を保つために処理中のデータを他の処理から触らないようにロックするんです。 このロックの範囲が広すぎたり時間が長すぎたりすると他のユーザーの処理をどんどんブロックしてしまってシステム全体の精度を著しく低下させる原因になるんです。 ああ、整合性を取るための仕組みが逆にシステムの首を絞めてしまう可能性があると。 そうならないための重要な指針が一度のトランザクションで変更する集約は一つに限定し、その集約はなるべく小さく保つという考え方です。 集約。 ええ、ドメイン駆動設計の用語ですが、要は整合性を保つべきデータのまとまりのことです。 このまとまりを小さく保つことがロックの影響を最小限に抑えるための鍵となります。 いやー、深いですね。今回は、同時に処理が走ることで発生する致命的な不具合っていうすごく身近な問題から出発しました。 そして、データベースの制約をセーフティーネットとして使い、最終的にはビジネスロジックを技術的な詳細から守りつつ、整合性を担保するための様々なトランザクション管理パターンを探求してきましたね。 そうですね。トランザクションスコープ、AOP、ユニットオブワークといったパターンは単なる技術的な選択肢じゃないんですよね。 ビジネスのルールをいかにインフラの複雑さから守るか、というソフトウェア設計におけるある種の哲学の表れでもあるんです。 これで、あなたが次に整合性が求められる行動を書くとき、どのような選択肢があって何を考慮すべきなのか、より明確な視点を持てたのではないでしょうか。 では、最後に一つ思考の種をあなたに残しておきましょうか。 お願いします。 今回の話は、全部一つのデータベースの中で整合性を保つという話でした。 では、システムがもっと巨大で複数のマイクロサービスにまたがっていたらどうでしょう。 例えば、ユーザー情報を更新するサービス、確認メールを送信するサービス、そして検索インデックスを更新するサービスが全部バラバラに存在したとします。 この一連の処理全体をまとめて成功させるか、まとめて失敗させるには一体どうすればよいのでしょうか。 うわぁ、それはまた全然違う話になりそうですね。 ええ、これはまたさらに深い探求への入り口ですね。