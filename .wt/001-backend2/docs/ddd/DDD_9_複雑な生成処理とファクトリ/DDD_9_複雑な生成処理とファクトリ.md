誰でも一度は経験があると思うんですけど、あるクラスのインスタンスを作りたいだけなのに、なぜかデータベース接続の準備まで必要になって あーありますね ユニットテストがすごく面倒になったことってありませんか? それはもう開発者あるあるの悩みですよね ですよね。今回はあなたが共有してくれた資料、ドメイン駆動設計qfactory.pdfをもとに、そんな作るのが面倒なオブジェクトの問題をスマートに解決する ファクトリーっていう考え方、これを探っていきたいと思います いいテーマですね。資料の冒頭にある道具を作ることと道具を使うことは全く別の知識であるっていうアナロジーがまさにその問題の本質をついてます はい。今回はオブジェクトの責任をどう分けるかっていう視点で深掘りするとすごく面白い発見があるはずですよ 責任の分離ですか?なるほど。では早速そこから紐解いていきましょうか はい 資料の例え話すごくわかりやすいですよね。私たちはコンピューターを使うとき、そのCPUの設計とかメモリの仕組みなんて知らなくても問題なく使えます ええ、使えますね オブジェクト思考も同じで、クラスの使い方が分かっていればその中身がどうなっているかを意識せずに済むと はい。それこそがカプセル化がもたらす素晴らしい恩恵です。ただ問題はここからなんです と言いますと? そのコンピューターを作るとなると話は全く別じゃないですか ああ、なるほど 部品を集めて、組み立てて、OSをインストールして、非常に複雑なプロセスです プログラムの世界でも全く同じことが起きると。特にドメインモデルの中心になるような重要なオブジェクトは、生成する過程でいろんな情報が必要になって、その製造過程が複雑になりがちだと そうなんです で、その複雑な処理を例えばユーザークラスのコンストラクターなんかに全部書いてしまうと まあ悲劇の始まりですね ほう それはソフトウェア設計の基本原則、である関心の分離とか単一責任の原則に、もう真っ向から反してしまうわけです うーん ユーザーオブジェクトの責任はあくまでユーザーというビジネス上の概念を表現すること、データベースへの接続方法とかIDの裁判方法というのは全く別の関心事なんですよ はいはい この2つを混ぜてしまうと、片方を変更するたびにもう片方が影響を受けるっていう非常に脆い行動になってしまいます なるほど、ユーザークラスにデータベース接続ロジックを書くのはまずいと じゃあその汚い仕事は一体どこに持っていけばユーザークラスをクリーンに保てるんでしょうか そこで登場するのがその名の通り工場、つまりファクトリーです 工場 ええ、オブジェクトの生成という複雑で時々ダーティーな仕事を専門に引き受ける別のクラスを用意しようという考え方ですね そのファクトリーが活躍する具体的なシナリオとしてユーザーIDの裁判処理が挙げられていますね はい、非常にわかりやすい例です 最初の実装はすごくシンプル、新規ユーザーを作るときコンストラクタの中でUUIDっていうユニークな文字列を生成してIDにする これはクラス内部で完結していて特に問題はなさそうです この時点では、問題は要件が変わったとき IDはデータベースの連番を使ってくださいと言われた途端状況は一変します そしてやってしまいがちなのが問題のある実装として挙げられているDIST9.2のコードですね そうですね データベースに接続してシーケンスから新しい番号を取ってくるロジックをユーザークラスのコンストラクタに直接書いてしまっている これが本当に典型的な罠なんです ユーザーというドメインの核となる高レベルな概念の中にデータベース接続という非常に低レベルないわばインフラの処理が混入してしまっている うーん、こうなるとテストが地獄になるんです 私も若い頃テスト実行するのに3分かかるコードを書いてしまって 3分ですか? えー、ちょっと動作確認のつもりが待ってる間にコーヒーを入れに行ってそのまま別の作業を始めちゃったなんて苦い経験がありますよ すごくわかります その問題を解決するのがファクトリー導入というわけですね はい 手順としてはまずiUserFactoryというインターフェース つまり設計図を定義する ええ ここにはユーザーネームを渡すとユーザーを返してくれるクリエイトメソッドがあるだけ 非常にシンプルです そうです そしてその設計図に基づいて具体的な工場、ユーザーファクトリークラスを作ります 先ほどユーザークラスの中にあったデータベース関連のごちゃごちゃした処理はすべてこちらに引っ越してきます うわー、これは劇的ですね リスト9.5のユーザークラスを見ると以前のコードにあったデータベース関連の記述が一切ない ええ まるで別物です これならこのクラスの責任がユーザーという概念そのものであることが一目瞭然ですね その通りです コンストラクタも外部からIDと名前を受け取るだけの非常に素直な形になっている 責務が完全に分離されました そしてこのアプローチの進化が発揮されるのがテストの場面なんです テストですか ええ リスト9.7にあるようにテスト用のインメモリーユーザーファクトリーを驚くほど簡単に作れるようになります これはデータベースになど接続せず内部のカウンターを一つ増やすだけのもう本当に単純なものです なるほど 本番ではデータベースにつなぐファクトリーをテストの時にはこのインメモリーのまあ言うなれば偽物ファクトリーに差し替えることができるんですね ええそれこそが依存性の注入リペンデンシーインジェクションの力です つまり使う側が使われる側を直接作るんじゃなくて外部から関西製品を注入してもらう設計ですね はい こうすることでテストが高速かつ独立して行えるようになります これは強力ですね ええでもここで一つ素朴な疑問が 何でしょう 開発チームに新しく入ってきた人がユーザークラスのコードだけを見てもインスタンス化にはユーザーファクトリーを使うべきだということにどうやって気づけばいいんでしょう ああ良い視点ですね 魔法のような仕組みは時として発見しにくいものですからね ええ ここで提案されている解決策は驚くほどシンプルでパッケージによるグルーピングです パッケージですか はいユーザークラスとiユーザーファクトリーインターフェースを例えば snsdomain.models.users のような同じパッケージに配置する そうすれば開発者は自然と両者の関連性に気づいてああユーザーを作るにはこのファクトリーを使うんだなと推測しやすくなります なるほど関連するものを近くに置くという基本は大事なんですね そういうことです ところでこのファクトリー以外のアプローチもいくつか紹介されています 例えばデータベース自体が持つ自動裁判機能を使う方法 はいこれも非常に一般的な方法で強力です ただ面白いトレードオフがあって トレードオフ ID はデータベースに保存された後に決まるという点です つまりコード上でインスタンスを生成した直後は ID が空っぽの不安定な状態になってしまう これは ID によって1位に識別されるべきエンティティの定義と少し矛盾を感じますよね ID がないユーザーオブジェクトですか それはなんだかこう気も気地悪いですね でしょうしかも後から ID をセットするために ID プロパティにセッターを公開する必要が出てきます ああ これは本来普遍であるべき ID が意図せず変更されてしまうリスクを生みます このアプローチには開発者間の暗黙の了解と強い自制心が必要だと書かれていますが これは気をつけないとすぐバグるよという遠回しな警告ですね なるほどもう一つの大対案としてリポジトリに裁判用のメソッドを持たせるという点も紹介されていますね ええこれはファクトリーという新しいクラスを作るほど大げさではなく ID が空になる不安定さも避けられるのでとても気楽な選択肢と評価されていますね ふむふむ まずリポジトリから ID を払い出してもらってその ID でユーザーを生成するという流れです 一見これが一番バランスが良さそうに聞こえますが ええ王道ですがちょっと待ってくださいリポジトリの本来の責務って何でしたっけ えっとデータの永続化と再構築つまり保存と読み込みですね そうですそこに裁判という新しい責務が加わるのは少し責任を持たせすぎではないかという見方もできるんです ああなるほど 特に裁判は外部 API 永続化はデータベースというように技術が異なる場合 一つのクラスに複数の関心事が門在して少しいわぎに感じるかもしれません 確かに これも絶対的な間違いではなくチームでの合意次第ですが設計の純粋さという点ではトレードオフがある選択肢です なるほど つまりリポジトリに裁判を任せるのは手軽ですけどクラスの責任という純粋さを少し犠牲にするトレードオフがあるわけですね そういうことになりますこの責任というキーワイドで考えると実はファクトリにはもう一つカプセル化という責任を守るための面白い使い方があるんですよ おっというと 資料の後半で触れられているファクトリーメソッドの話です あーその通りですこれはファクトリーメソッドと呼ばれるパターンであるオブジェクトが自分の内部情報を使って別のオブジェクトを生成したい でもその内部情報は外部に公開したくないというジレンマを解決してくれます 資料の例はユーザーがサークルという別のオブジェクトを作るケースですね ええ サークルを作るにはオーナーであるユーザーのIDが必要 普通ならユーザー.ゲットIDみたいなゲッターを用意しそうですけど しかしIDのような重要な情報を安易に公開したくない そこでユーザークラス自身にクリエイトサークルというメソッドを持たせるんです ほうほう このメソッドが外部からは見えない自身のIDを使ってサークルのインスタンスを生成して返す これがファクトリーメソッドです クラス全体が工場なのではなく 一つのメソッドが小さな専門工場として機能するイメージですね なるほど ユーザーの内部情報を守りつつ関連オブジェクトを安全に生成できる 非常にエルガントな方法です 面白いですね では最後にそもそもファクトリーを導入すべきか迷った時 何か判断のヒントになるようなものはありますか はい 一つ非常に実践的な指標が示されています コンストラクターの中で他のオブジェクトを入手しているかです コンストラクターの中で入手ですか コンストラクターの本来の仕事は受け取った部品で自分自身を組み立てること その中でさらに別の部品を作り始めると途端に処理が複雑になります ああ確かに そういう兆候が見えてらそれはそろそろ生成の仕事を専門家 つまりファクトリーに任せた方がいいんじゃないというサインだと考えるのが良い習慣ですね ここまでいろいろなパターンを見てきましたが一度立ち止まって考えてみましょうか 結局このファクトリーという考え方の本質は何なんでしょうか 単なるテクニックというよりは高度の責務を分離して 意図を明確にするための設計思想そのものという感じがします まさしくその通りです オブジェクトのライフサイクルには生成と利用と破棄がありますが その生成という厄介な部分を専門家に委ねる へえ これによってドメインモデル本体を本来の責務 つまりビジネスロジックの表現に集中させることができるんです なるほど 資料の最後の言葉を借りるなら ファクトリーやリポジトリーはビジネスの専門家が語る言葉ではありません でもそのドメインを動くソフトウェアとして完成させるためには不可欠な支援役なんです 支援役ですか ドメインモデルが主役なら彼らは最高の助言俳優 その存在を正しく認識し適切な役割を与えることが美しい設計への鍵だということです なるほど非常にしっくりきました さて今回は新しいオブジェクトを生成することに焦点を当てました はい では少し視点を変えてデータベースなどからデータを読み込んで 既存のオブジェクトを再構築する場合はどうでしょうか この再構築のプロセスにも独自の複雑さが伴うことがあります このオブジェクトを生き返らせる複雑な処理を管理するために ファクトリーやあるいはそれに似た考え方は応用できるでしょうか ぜひ考えてみてください