ソフトウェア開発で一番最初に決めることででもその後ずーっと何年にもわたって僕たち を助けてくれたり逆に縛ったりするものって何だと思いますか 僕はそれがソリューション構成つまりファイルとかフォルダーをどういうふうに配置するか っていうあの最初の設計図だと思うんですよね 今日はですねナルセノブネンさんの著書 ドメイン駆動設計入門からこの非常に重要なんですけど意外と見過ごされがちなソリューション構成 というテーマを掘り下げていきたいとおもいます 今あなたが関わっているプロジェクトのフォルダ構成 なんでそうなっているかすぐに説明できますか この話を聞きながらその理由を改めて考えてみるときっと新しい発見があるはずです 今回はレイヤードアーキテクチャーを例にして小さなパッケージの分け方から プロジェクト全体の大きな設計思想までその革新に迫っていきましょう まさに設計思想の表明ですよね 優れたソリューション構成っていうのは新しいメンバーがプロジェクトに入ってきたときに コードを読む前にこのシステムが何を大切にしているかを語りかけてくれるような いわば無言のドキュメントになるんですよね 単なる整理整頓とは似て非なるものだなと 無言のドキュメント面白いですね じゃあ早速そのドキュメントの読み解き方を見ていきましょうか まずは家全体の設計図を見る前に部屋の中の家具の配置 つまり各レイヤーのパッケージ構成からですね ソースではレイヤードアーキテクチャーの4つのレイヤープレゼンテーションアプリケーション ドメインインフラストラクチャーを例に挙げてますね この中でやっぱり一番気になるのは心臓部であるドメインレイヤーです ソースの図を見るとドメインドットモデルドメインドットサービス ドメインドットシェアードと分かれている ドメインドットモデルの中がサークルズとかユーザーズみたいに複数形になっているのがまず目につきました これ何か理由があるんですか いいところに気づきましたね それ c シャープの言語使用に根差したささやかですけどすごく重要な工夫なんです c シャープだとクラス名とそれが属している名前空間が全く同じ名前だと コンパイラがちょっと混乱することがあって なのでユーザークラスを

ユーザーズっていう名前空間に入れることで その衝突を避けてるっていうわけです Javaとか他の言語だと むしろ単数形にするのが一般的だったりしますね なるほど いきなり言語の特性が 構成に影響するっていう話が出てきましたね でももっと驚いたのは そのユーザーズパッケージの中身ですよ ユーザーっていうエンティティクラスだけじゃなくて iUserリポジトリ、リポジトリとか iUserファクトリー、ファクトリーまで一緒に入ってる 正直僕だったらドメイン.リポジトリみたいな フォルダを作って そこに全部エイヤーってまとめてしまいそうですけど その方がスッキリする気がしません? そう考える方は非常に多いと思います 種類ごとにまとめるっていうのは すごく直感的ですからね ですがここでソースが提示している 秀逸な例え話が役に立つんですよ 同じ切るものという理由でキッチンに置くべき包丁と 書斎に置くべきカッターを同じ戸棚にしまいますか? いやそれはしないですね 包丁は調理器具でカッターは文房具 用途が全然違う あ、なるほど リポジトリとかファクトリーもそれ単体であるんじゃなくて あくまでユーザーっていうエンティティと密接に関わって初めて意味を持つものだから だからユーザーの近くに置くべきだっていうことですか? まさにその通りです ユーザーを新しく生成するのはファクトリーの役割 一度永続化されたユーザーをデータベースから復元するのがリポジトリの役割 これらはユーザーのライフサークルにものすごく深く関わってます これらをユーザースパッケージに同居させることで これらは一つの意味的な塊ですよとか ユーザーを扱うときはファクトリーとかリポジトリのことも 一緒に考えてくださいねっていう強いメッセージを 後の開発者に伝えることができるんです これは属性による分類じゃなくて 強襲性 つまり関連性の強さに着目したパッケージングの考え方なんですよね そのカッターと包丁の例えはすごくわかりやすいですけど 少し意地悪な見方をすると チームによっては とにかくリポジトリのインターフェースは 全部このリポジトリフォルダを見ればいいっていうルールの方が 迷いがなくて開発しやすいみたいな考え方もあるんじゃないでしょうか あーそれは非常に鋭い指摘ですね

はい、小規模なチームとかドメインが比較的シンプルなプロジェクトだったら そのやり方の方が効率的な場面もあるでしょう ただ、ドメインが複雑になってユーザーに関するルール サークルに関するルールがそれぞれ専門化してくると 関連するものが物理的に近くに配置されていることの価値が 遠くに分散していることの不便さを上回ってくるんですよ 教習性の高い設計っていうのは将来の変更に強い 例えばユーザーの使用変更があったときに 変更箇所がユーザーズパッケージの中にまとまっている可能性が高くなる これって長期的な保守性を考えるとものすごく大きなメリットになります なるほど、短期的な分かりやすさか長期的な保守性かっていう そういうトレードオフの視点もあるわけですね、深いな アプリケーションレイヤーの構成はどうでしょう こっちはサークルズとかユーザーズといった機能ごとに分かれていて 比較的シンプルに見えますね ええ、アプリケーションレイヤーはユースケースを実装する層なので 機能ごとに分けるのは自然なアプローチだと思います ソースではもう一つクリーンアーキテクチャ料理の構成も紹介されてますね クリエイトとかゲットとか より細かいユースケース単位でパッケージを分ける考え方です 一つのユースケースが一つのクラスに対応するような より責務を細かく分けたい場合に有効な構成で これもどちらかが劣態的に良いというわけじゃなく チームがどのくらいの粒度で仕事を管理したいかによりますね 最後のインフラストラクチャレイヤーは EF、エンティティフレームワークとか インメモリーとか具体的な技術ごとに分かれてて これは直感的で分かりやすいですね そうですね、ここはもう具体的な実装技術を閉じ込める場所なので 技術名で分けるのが一番合理的です さて、これで部屋の中の家具の配置は決まりましたと 部品の整理整頓だけでもこれだけ思想が反映されるんですね でもこれってまだ家の中の話ですもんね ここからはいよいよ家そのものの設計図 つまりソリューション全体の構成の話に進みましょう ええ、ここからがこのテーマの革新部分ですね 影響範囲が格段に大きくなりますから ソースでは大きく分けて2つの方針が示されています まず方針1、すべてを別のプロジェクトにする 図を見ると、SNSドメイン、SNSアプリケーション、プレゼンテーションといったレイヤーが それぞれ完全に出てくる

独立したプロジェクトとして作られてますね この構成の最大の魅力は 何と言ってもドメインレイヤーの再利用性です SNSドメインプロジェクトは 特定のアプリケーションに依存しない 純粋なビジネスルールの塊になります つまりこのドメイン知識を使って ウェブアプリケーションだけじゃなく デスクトップアプリとかバッチ処理ツールとか 全く新しいアプリケーションを 比較的簡単に作ることが可能になるんです その再利用性っていうのはめちゃくちゃ魅力的ですけど でもちょっと待ってください プロジェクトが物理的に分かれるっていうことは アプリケーションレイヤーから ドメインのクラスを呼び出すには そのメソッドをパブリック つまり公開状態にする必要がありますよね それだと本来アプリケーションサービスからしか 呼ばれたくないはずの重要なメソッドが プレゼンテーションレイヤーとか ルールを知らない人からどこからでも呼び出せてしまう それってすごく危険な気がするんですけど どうなんでしょうか まさにそこがこの構成の最大のリスクであり トレーズオフなんです 意図しない使われ方を防ぐための仕組みが弱くて 開発者一人一人の規律に頼ることになる ソースでも本来アプリケーションサービスに 記述されるべきコードが プレゼンテーションレイヤーに分散してしまうっていう 危険性を指摘しています それは怖いですね 忙しいプロジェクトだと まあここから直接呼んじゃえみたいなことが 絶対起きそうです 起きますね 以前私が関わったプロジェクトで まさにそのパブリック問題で 痛い目を見たことがあります 最初はDTO データトランスファーオブジェクトへの詰め替えを 徹底するっていうルールで カバーできると思ってたんですよ でも納期が迫ってくると そのルールが徐々に破壊され始めて プレゼンテーション層に どんどんビジネスロジックが漏れ出してしまって 半年後にはもうどこで何が行われてるか 誰も全容を把握できない スパゲッティコードの塊になってしまいました リアルな話 聞いてるだけで胃が痛くなります だからこそ 仕組みで防ぎたいってなるわけですね そこで出てくるのが方針2の アプリケーションとドメインだけ 同じプロジェクトにするっていう構成ですか その通りです この構成は先ほどの問題を解決するたれの 非常にエレガントな一手なんですよ Cシャープには インターナルっていうアクセス就職者があるんですけど これが鍵になります

インターナルで宣言されたクラスとかメソッドは 同じプロジェクトの中からしかアクセスできないんです ああ なるほど ユーザークラスのチェンジネームメソッドを インターナルに仕置けば 同じプロジェクト内にあるアプリケーションサービスからは 問題なく呼び出せると でも別のプロジェクトであるプレゼンテーションレイヤーからは そもそも呼び出そうとしてもコンパイルエラーになる 規律とかルールじゃなくて コンパイラーが門番になっていかれるわけですね これは強力な安全装置だ ええ 意図しないメソッドの呼び出しっていう 非常に厄介なバグの音症を設計レベルで根絶できる これは大きなメリットです でももちろんこれもタダではないですよね この安全性を手に入れる代わりに何を失うことになるんですか 失うのは方針1の最大のメリットだった再利用性です インターナルで守られたドメインオブジェクトは そのプロジェクトの中に完全に閉じ込められちゃうんです だから方針1みたいにドメインレイヤーだけを 別の新しいアプリケーションで使い回すということが 基本的にはできなくなります 再利用性を取るか呼び出しの安全性をコンパイラーに保証させるか これがソリューション構成における非常に大きな選択になるわけです これは悩ましい選択ですね ここまでCシャープを例に見てきましたけど ソースでは他の言語についても触れててこれがまた面白い Javaにはインターナルよりももっと狭い 同じパッケージ内に限定するパッケージプライベートがあったり Scalaにはもっときめ細かなアクセス制御ができる 限定詞っていう機能があったりするんですね そうなんです ここが本当に重要なポイントで 最低なソリューション構成は あなたが使うプログラミング言語がどんな武器 つまりどんなアクセス制御機能を持ってるかに大きく依存するんです それはまるで大工さんが持ってる道具によって 作れる家のデザインが変わってくるようなもので Cシャープのインターナルは家全体にかける大きな鍵 Javaのパッケージプライベートは部屋ごとにかける小さな鍵 みたいなそんな具合に ということはこのソースに書かれている構成例を そのまま真似するだけじゃダメで 自分の言語の特性を深く理解した上で 自分たちのプロジェクトに最適な形を模索する必要がある ということですね 銀の弾丸は存在しない

まさに大切なのは なぜその構成を選択したのか その理由 そのトレードオフを自分の言葉でチームメンバーに説明できることなんです このプロジェクトでは ドメインの再利用性よりも 呼び出しの安全性を重視したい だから ドメインとアプリケーションを同じプロジェクトにして インターナルで防御を固める戦力を選んだんだっていうように 考え抜かれたソリューション構成には美しさが宿るっていうソースの言葉が 今ならすごくよくわかります コードをどこに置くか その理由を自問自答すること自体が 設計の醍醐味であり 開発の楽しみの一つなんですね というわけで 今回はドメイン駆動設計におけるソリューション構成について 深く掘り下げてきました 今日の話をまとめると まず一つ目は パッケージを分けるときは あのカッターと包丁の例えを思い出して 属性じゃなくて意味的なまとまりを意識すること 二つ目は ソリューション全体の構成には大きな選択肢があって 再利用性を取るか 呼び出しの安全性を仕組みで担保するかっていう大きなトレードオフが存在すること そして三つ目は 絶対的な正解はなくて 使う言語の特性を理解して なぜこの構成なのかを自分の言葉で語れることが何よりも重要だ ということでした これらの選択の一つ一つが 数ヶ月後 数年後の自分自身や 新しくチームに加わる仲間へのメッセージになりますからね 構成そのものがシステムの意図を有弁に物語るドキュメントになる そう考えると少し楽しくなってきませんか 本当ですね さて最後に一つ あなたに考えてみてほしい問いを投げかけたいと思います 今回私たちはドメインレイヤーの再利用性を大きなテーマとして議論しました しかしマイクロサービスアーキテクチャーが主流になりつつある現代において プロジェクトを直接参照してドメインモデルを再利用するというアプローチは 本当に今でも最善な策なんでしょうか あるいはそれはサービス間に新たな見つけ口を生み出すだけの アンチパターンになりつつあるのではないでしょうか あなたのプロジェクトが本当に求める再利用性とは一体何なのか この機会にぜひチームで深く議論してみてください