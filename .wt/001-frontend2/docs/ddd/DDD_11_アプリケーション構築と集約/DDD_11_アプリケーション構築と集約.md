こんにちは the deep dive へようこそ 早速ですけどコードを読んでいてふと出てきた数字 例えば29っていう数字にあれって違和感を覚えたことありませんか 特にあの使用書とかルールにはちゃんと上限は30ですって書いてあるのに なぜかコードは29になってるみたいな 今日はまさにそんな謎の数字が実はソフトウェアに仕掛けられた まあ次元爆弾かもしれないというお話です ドメイン駆動設計いわゆる ddd に関する資料をもとにこの爆弾がどうやって作られてしまうのか そしてそもそもどうすれば仕掛けずに済むのかを一緒に解き明かしていきましょう よろしくお願いします その違和感すごく鋭い指摘だと思います それって実は単なるコーディングミスとかそういう話じゃなくてもっと こんな深い設計上の問題なんですよね つまりビジネスのえっとすごく重要なルールがあるべき場所から漏れ出してしまっているという危険な サインなんですよ ルールが漏れ出ているなるほど面白いですね じゃあそもそもそういう問題を起こさないためにはどこから手をつければいいんでしょう この資料によるとどうやら機能開発にはある種の方というか理想的な流れがあるみたいですね そうなんですまず大前提として何を作るかを決めますよね これがまあ機能要求の確認です はいで次にその機能を実現するためにユーザーがどんな操作をするのか ユースケースを具体的に洗い出していく ふむふむここまではごく自然な流れだと思います 例えば今回の資料で取り上げられている sns のサークル機能で言うとユーザーが新しいサークルを作るとか あとは既存のサークルに参加するみたいなそういうのがユースケースに当たるわけですね その通りですでここからが ddd の面白いところでそれらのユースケースを成り立たせるための ビジネス上のルール これを明確に定義していくんです 今回のサークル機能だと資料には3つの重要なルールが挙げられていますね えっとありましたねまず一つ目が サークルの名前は3文字以上20文字以下 これはわかりやすいですね短すぎたり長すぎたりする名前はダメですよと でここで一度立ち止まるのが重要なんです ddd ではこういうルールをただのコメントとか 仕様書の記述だけで終わらせないんですよ サークル名という概念そのものにこのルールを埋め込んでしまう 具体的には値オブジェクトバリューオブジェクトという考え方を使います 値オブジェクト つまりサークル名っていうただの文字列として扱うのではなくて 3文字以上20文字以下であることが保証されたサークル名っていうルールと一体化 した1個のものとして扱うということですか まさにその通りです素晴らしい サークル名というオブジェクトを作るその瞬間に文字数チェックを強制するんです そうすることでそのオブジェクトが存在する限りルール違反の状態は絶対に起こり得ない なるほど不正なデータがシステムに紛れ込むのを いわば入り口で防ぐ非常に強力な手法です面白いですね オブジェクトが自分自身の正しさを保証してくれるわけだ ちなみに2つ目のルールはサークル名は重複してはならない これって一つのオブジェクトだけでは判断できないですよね 他の全部のサークル名を知らないといけないから良いところに気づきましたね そうなんです ですからその役割はドメインサービスと呼ばれる 複数のオブジェクトを横断してチェックする別の専門家が担当することになります なるほどオブジェクトに事後完結できるルールはオブジェクト自身に持たせる でもそうじゃないルールは専門家に任せる この適切な役割分担が大事なんですわかりやすいです そして最後のルールが今回の話の確信ですね サークルの所属メンバーはオーナーを含めて最大30名まで これがあの29の謎につながっていくわけだ そういうことです さでこれでルールをオブジェクトに落とし込む準備ができました いよいよこれらを使ってユースケースつまり実際の機能を組み立てていきます オッケーですビルディングブロックは揃ったと ではアプリケーションのコードを見ていきましょう まずサークルを作成する処理はふむふむ コマンドでユーザー id とサークル名を受け取ってオーナーを確認して でさっきの値オブジェクトとか ドメインサービスを使ってサークルを生成して保存すると ここはすごく綺麗に見えますね ええここは ddd の考え方がうまく反映されていますね ですが問題は次です サークルに参加する処理のコードここで僕がうーんってなった一行が出てくるんですよ これです イフカッコサークルドットメンバーズカッコカウントかっこ イコール29 やっぱりこれおかしいですよねルールは最大30名なんですよ なのになぜコードは29でチェックしているのか これは一体どういうことなんでしょうその数字のズレこそが先ほど言った ルールが漏れ出している決定的な証拠なんです 証拠なぜ29なのかその理由はサークルというクラスの内部構造にあります このクラス実はサークルのオーナー一人とそれ以外のメンバーを別々のリストで管理しているんですよ なるほど つまりアプリケーション側がオーナーが一人いるからメンバーが29人になったら合計で30人だっていう 計算を勝手にこう気を利かせてやってしまっている状態なんだ その通りなんです サークルは30人までという大事なルールを知っているべきなのは本来的にはサークルオブジェクト 自身のはずじゃないですか それを外部のアプリケーションがサークルの内部構造を まあ覗き見て勝手に実装してしまっている 例えるならお城の防御設計図が城の外に持ち出されてみんながそれを勝手にコピー して使っているようなものですよ うわぁその例えすごくわかりやすいです それは気持ち悪いし何より危ないですね 今はたまたま正しく動いているかもしれないですけど 例えばこの後メンバーをサークルに招待するっていう新しい機能を追加したらどうなりますかね きっとその新しい機能を作る開発者の方はサークル参加のコードを参考にしますよね まあしますね普通は そしてそこに書かれているifカッコサークル.メンバーズ.カウントイコール29というロジックをあまり深く考えずにコピー&ペーストするでしょう ああやってしまいそう そうなると同じ人数の制限のロジックが少なくとも2箇所に存在することになりますね ええそして悲劇が起こるのはその数ヶ月後です ビジネスが成長してサークルの上限人数を50名に緩和しようという変更要求が来たとします さあどうなるでしょう うわぁ 開発者はまずコードの中から29っていう数字を探し回ることになりますね そうです でもその29が本当にサークルの人数制限を指しているのか 一つ一つ文脈を確認しないといけない もしかしたら全然関係ない処理の29かもしれないしそうなんです そしてどこか一箇所でも修正を漏らしたらそこだけ古い30人制限が残ってしまう バグになりますね あるいは関係ない29を49に変えてしまって別のバグを生むかもしれない これこそがソフトウェアの保守性を著しく下げる典型的な失敗パターンなんです なるほど問題の根本はもうはっきりしていて 一つの場所で管理されるべきルールがあちこちに散らばってしまっていること これにつきます いやー怖いですね 最初のほんの小さな違和感たった一つの数字のズレが将来の大きなバグとか修正コストに 直結していくわけですか 一見正しく動いているコードの裏にこんな時間爆動が隠れていることがあるんですね だからこそルールを縛るべき場所にこう閉じ込めて 外に漏れ出させない設計が重要になるわけです 言葉で表現されたルールとコードの表現が常に一致している状態を目指す それが ddd の目指す世界の一つなんですね なるほど今日の話まとめると ddd の具体的な実装フローを追いながらドメインのルールをどこに書く べきかという非常に重要な教訓を学んだ気がします そして一見確かに動いているコードにも潜む悪い兆候を見抜く目を養うことの大切さがよくわかりました では最後にディスナーの皆さんに一つ考えてみてほしい問いがあります そしてこれが次の学びへの扉になります ではこのメンバー上限数というルールが点在してしまう問題を解決するには本当はどうすれば よかったのでしょうか どうすればよかったのかはいこの問いへの鍵となるのが集約 英語で言うとアグリゲートという ddd の非常に重要な概念です 集約はいこれはサークルとかそのメンバーリストといった 本来一体として扱われるべきオブジェクト群を一つの塊として定義するんです そしてその塊の整合性を外部から壊されないように守るための強力なパターンなんですよ もしこの考え方を使っていれば人数制限のロジックはこの集約という名の 金庫の中にただ一箇所だけ書かれて外に漏れ出すことは決してなかったはずです 集約なるほどその金庫があれば設計図が外に持ち出されることもなかったと その話ぜひまた別の機会にもっと深く掘り下げてみたいですね