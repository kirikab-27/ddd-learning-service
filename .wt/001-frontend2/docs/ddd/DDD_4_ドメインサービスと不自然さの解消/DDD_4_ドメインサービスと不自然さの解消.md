
今回はあなたが送ってくれたドメイン駆動設計 いわゆるDDDに関する資料の中から 特にドメインサービスっていう考え方に焦点を当てて 一緒に深く掘り下げていきたいと思います ソフトウェア開発ってなんかいつも一つの戦いだと思うですよね ビジネスの本質的なルールを純粋に保ちたいっていう理想と それをデータベースみたいな具体的な技術で動かさなきゃいけないっていう その現実との戦い 今日はですねその戦いにおける一つの強力な武器 ドメインサービスについて見ていきましょう 資料を読んでみるとこれ単なる便利な道具っていうだけじゃなくて 設計思想そのものが問われるかなり奥深いテーマみたいですね まさにそして最初に抑えておきたいのが資料でも強調されている点なんですけど サービスっていう言葉の使い分けですね あーはいはい ソフトウェアの世界ではアプリケーションサービスとかインフラサービスウェブサービス もういろいろなサービスが飛び交えますよね 会社にでも ddd でいうドメインサービスはそれらとは明確に区別される あくまでドメインの関心事を扱うためのものなんです この区別が今日の話全体のまあ土台になりますね なるほどその区別は大事ですね じゃあそのドメインのためのサービスが具体的にどんな問題を解決してくれるのか 資料にあるユーザーネームの重複チェックっていうすごく身近な例で見ていき ましょうか いいですね新しいユーザーを登録するときに同じ名前の人がすでにいないか確認するっていう処理ですね これどこに書くのが自然だと思いますか これが意外と悩ましいんですよねオブジェクト思考の基本に忠実に考えると ユーザーに関することはユーザークラスに書くべきだってまあなりますよね なりますねそこで資料にある最初の失敗やみたいに ユーザークラス自体にエクジスユーザーみたいなメソッドを実装したくなるわけです ユーザードットエグジストユーザー 交付にするとこうですね でもこれえーとなんだか変な感じがします 自分のインスタンスに対して自分は全体の中に存在しますかって聞いてるみたいでそうなんですよ なんか哲学問答みたいになってしまいますよね 開発者が見たらこれトゥルーが買えるのフォルスが買えるのって単語

混乱しそうですその不自然さがまさに問題の確信なんです それはまるで本の1ページを指し指してこの本は本棚にありますかって聞いているような ものなんですよね あーなるほどページ自身は本棚全体の状況なんて資料でもないじゃないですか ユーザーっていう個別のオブジェクトも他のすべてのユーザーのリストを持っているわけでは ないのでこの問いには答えられないんです 確かにじゃあ資料にあるもう一つの失敗案 重複チェックのためだけにニューユーザーチェックユーザーみたいな なんか特殊なインスタンスを作るっていうアイデアそれも結局 ユーザーでありながら本当のユーザーではないっていうこう矛盾した存在を生み出して しまいますからね そういう不自然のものを作らなければいけない時点で設計がどこか歪んでいるサイン なんです なるほどそこで登場するのがドメインサービスです ユーザーサービスという特定のユーザーではないもっと大きな概念を扱うクラスを用意して そこにエグジストユーザーっていうメソッドを置く ああなるほどユーザーサービス.エグジストユーザーと書けば ユーザーに関するサービス系にこのユーザーが存在するか問い合わせるっていうすごく 自然な文脈になりますね そうなんです誰が見ても直感的です つまりどの特定のエンティティにも属さないけれど ドメインにとっては重要な操作とか活動の置き場所がドメインサービスなんですね その通りです 個々のものに責任を押し付けるのが不自然な場合にその活動自体をオブジェクトとして モデリングするという発想の転換ですね これはすごく強力なパターンですね 今まで置き場所に困っていた処理がすっきりと片付く感じがします でもこれだけ便利なものだとついつい何でもかんでもドメインサービスに書きたくなってしまい そうです 何かデメリットとか乱用するリスクはあるんでしょうか いい質問ですねそれこそがDDD初心者が最も陥りやすい そして最も危険な罠なんです 資料でドメインモデル貧血症として紹介されている問題ですね ドメインモデル貧血症名前からしてなんか不健康そうな響きですけど 文字通りドメインモデルが栄養失調でスカスカになってしまう状態です 例えばユーザーの名前を変更するチェンジネームというメソッド はい これは明らかにそのユーザー自身のデータと

そのユーザー自身のルールに基づいていますよね 本来ならユーザークラスが持つべき最も基本的な振る舞いのはずです もちろんです user.changename newname と書きたいです ところがドメインサービスに慣れてしまうと 名前の変更もユーザーに関するサービスだからって 安易にユーザーサービスに changename user newname っていうメソッドを作ってしまう これを繰り返していくとどうなると思いますか ユーザークラスからどんどんメソッドが消えていって 最終的には名前とかメールアドレスといった データを持っているだけのただの入れ物になってしまうとかですか まさにそれです ゲッターとセッターしか持たない空っぽのクラス これがドメインモデル貧血症です データとそのデータを操作するロジックが完全に分離してしまう これはデータと振る舞いを一体化させてカプセル化するっていう オブジェクト思考の根本的な思想とは真逆のやり方なんです でもロジックが全部ユーザーサービスみたいなサービスクラスにまとまっていた方が どこに何が書いてあるか分かりやすいっていう考え方もできませんかね 探す場所が一つで済むみたいな 一見そう思えるのがこの罠の巧妙なところなんですよね でもそれはソフトウェアが小さいうちだけの話で 実は私も若い頃この貧血症モデルで大きなシステムを作ってしまって 後々の改修で本当に地獄を見ました ビジネスルールが知りたければサービスクラスを データ構造が知りたければエンティティクラスを見なきゃいけなくて 常に2つのファイルを行き来するんです そして最悪なのはユーザーオブジェクトを見ただけでは そのユーザーがシステム上で何ができるのかが全く分からない ドメインの知識がモデルから失われてしまうんです それは生々しい経験から来る言葉には重みがありますね ですから資料にある指針が非常に重要になります 振る舞いをどこに置くか迷ったら まずエンティティか値オブジェクトに置けないか徹底的に考えること ドメインサービスはどうしても不自然な場前にのみ使う 最後の手段と心得るべきだと なるほど原則はあくまでエンティティ サービスは例外とよく分かりました ただ最後の手段というとネガティブに聞こえますけど ドメインサービスが主役になるべき完璧にフィットする場面は

ももちろんありますその良い例が資料の後半で紹介されている物流システムの話ですね これはデータベースが絡まないより純粋なドメインの活動を考える上で非常に興味深い 例ですよ 物流の輸送ですね荷物を影響点から b 拠点へ移すという活動 a この輸送っていう活動は必ず a 拠点からの出庫と b 拠点への入庫っていう2つの 操作がセットで行われますよね はいそうですね片方だけ実行されたら荷物が消えてしまうか どこからか湧いて出たことになってしまいますから さてこの輸送という一連の振る舞いは a 拠点と b 拠点 どちらのオブジェクトの責任にすべきだと思いますか a 拠点のメソッドにするウェアハウス a ドット トランスポート2ウェアハウス b カーゴみたいな でも a 拠点が b 拠点の中身を直接操作するみたいでちょっと気持ち悪いですね オブジェクト同士の結合が強くなりすぎるというか その通りです各拠点は自分自身の出庫と入庫の責任は持つべきですが 他の拠点を直接操作する権限を持つべきではない ここでトランスポートサービスというドメインサービスが輝くんですね このサービスが調整役になるんですつまり トランスポートサービスドット エグザキュートウェアハウス a ウェアハウス b カーゴみたいな形で呼び出すと でサービスの中ではまずウェアハウス a から荷物をシップ つまり出庫させて次にその荷物をウェアハウス b にリシーブ 入庫させるという流れを管理するわけですね a そしてここからがさらに面白いところです もし出庫は成功したけど輸送中にトラブルがあって b 拠点での入庫に失敗したらどうしますか 確かに荷物が宙に浮いた状態になってしまう そういう時にトランスポートサービスが進化を発揮します 入庫が失敗したことを検知して a 拠点に対して出庫を取り消すという保証トランザクション を実行したり管理者に緊急通知を送ったりする なるほどこのように複数のオブジェクトにまたがる一連のプロセス 特にその整合性を維持する責任を持つのがドメインサービスの最も得意な役割なんです これは

もう最後の手段どころか このサービスがなければ成り立たない 設計の主役ですよね なるほど 単なる置き場所じゃなくて 一連のビジネスプロセスを調整するコーディネーターなんですね ドメインサービスの見方が変わりました では 最初のユーザー作成のユースケースに 話を戻してみましょうか ユーザーサービスで重複チェックは自然になりました 物流の例でコーディネーターとしての役割も理解できました でも ここでまたあの最初の問いに戻ってくる気がします 純粋なビジネスロジックと現実の技術との戦いの話です というと? ユーザーサービスがユーザー名の重複をチェックするためには 結局データベースに問い合わせる必要がありますよね 資料のコード例でも サービスの中にデータベースを操作するコードが書かれています ええ 書かれていますね これって せっかくビジネスの関心事をユーザーサービスにまとめたのに そこにデータベースっていう技術的な詳細が 入り組んできちゃってませんか? 素晴らしい指摘です まさに一つの問題を解決したら 次の新たな課題が見えてきたという状況ですね ドメインの本質的なロジック つまり 重複がないか確認し ユーザーを作成し保存するということと それを実現するための技術的な詳細 例えば 特定のSQL文を組み立てて 特定のデータベースに接続するということが コードの中でごちゃ混ぜになってしまっている これでは もし将来データベースを MySQLから別のものに変えたいとなったら ユーザーサービスのコードを 直接書き換える必要が出てきます それは避けたいですね ビジネスロジックはビジネスの都合で インフラは技術の都合で それぞれ変更できるように分離しておきたいです その通りです そして その問題を解決するために ドメイン駆動設計では リポジトリという また別の強力なパターンが用意されています これも一種の関心の分離のための道具ですね リポジトリですか ええ すごく簡単に言うと リポジトリはドメインとインフラの間の 通訳みたいなものです 通訳 ユーザーサービスは データベースの存在を一切知りません ただ ユーザーリポジトリという通訳に対して この名前のユーザーはいますか とか このユーザーを

保存しておいてくださいとお願いするだけなんです その裏でリポジトリが実際にSQLを発行しようが テキストファイルに書き込もうが ユーザーサービスはしたこっちゃない このおかげでドメインサービスは 純粋なビジネスロジックにより集中できるようになるんです はあ なるほど ドメインサービスで振る舞いを適切な場所に配置して さらにリポジトリでデータ永続化を分離する そうやってどんどんビジネスロジックの 純度を高めていくんですね DDDのパーツが一つ一つ繋がっていく感じがして すごく面白いです それでは今回の話をまとめてみましょうか 一つ目はドメインサービスは 特定のオブジェクトに属させるのが不自然な 活動や操作を扱うための設計パターンであること 二つ目は非常に便利ですけど乱用すると オブジェクトから振る舞いが失われる ドメインモデル貧血症っていう 深刻な副作用を引き起こす危険があること 使いどころの見極めが重要ということですね そして三つ目は複数のオブジェクトに またがるプロセスを調整するコーディネーターとして ビジネスのルールを自然な形で表現する 強力なツールであること 素晴らしいまとめですね 最後にこの話を通して あなたに考えてみてほしい問いを一つだけ 資料の著者も触れていますが ドメインのルールを表現するために データベースのような外部の仕組みに アクセスするのは許されるのかという点 これ設計者の間で本当に意見が分かれるんです ユーザー名がユニークであるっていうよりは 結局データベースのユニーク制約がないと保証できない だからドメインロジックが データベースを知るのは当然だっていう意見もあれば いやドメインはあくまで純粋であるべきで インフラのことは一切知るべきではない っていう意見もあるわけですね そうです今日の話は結局純粋なビジネスロジックと それを実現するための技術の境界線を どこに引くべきかという ソフトウェア設計における根源的な問いに行き着きます あなたが次にシステムを設計するなら その境界線をどこに引きますか 絶対の正解はありません でもその問いへのあなた自身の答えが あなたが作るソフトウェア全体のアーキテクチャ そしてその未来を決定づけることになるでしょう